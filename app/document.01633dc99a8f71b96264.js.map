{"version":3,"sources":["webpack:///./app/scenes/Document/components/HideSidebar.ts","webpack:///./app/scenes/Document/components/DataLoader.tsx","webpack:///./app/scenes/Document/components/SocketPresence.ts","webpack:///./app/scenes/Document/index.tsx"],"names":["HideSidebar","componentDidMount","this","props","ui","enableEditMode","componentWillUnmount","disableEditMode","render","children","React","DataLoader","observer","onCreateLink","title","document","invariant","documents","create","collectionId","parentDocumentId","text","newDocument","url","loadRevision","revisionId","match","params","revisions","fetch","revision","loadDocument","shareId","documentSlug","setActiveDocument","fetchWithSharedTree","response","sharedTree","undefined","error","can","policies","abilities","id","update","isEditRoute","history","push","read","shares","catch","err","NotFoundError","getByUrl","getSharedTree","componentDidUpdate","prevProps","get","auth","user","path","matchDocumentEdit","team","collaborativeEditing","location","OfflineError","ErrorOffline","Error404","Loading","isEditing","key","readOnly","isArchived","observable","withStores","SocketPresence","setupOnce","context","previousContext","authenticated","emitJoin","on","emit","documentId","emitPresence","editingInterval","setInterval","USER_PRESENCE_INTERVAL","off","clearInterval","contextType","SocketContext","DocumentScene","useStores","useCurrentTeam","clearActiveDocument","urlParts","split","length","join","isMultiplayer","rest","isDeleted","Document"],"mappings":"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","file":"document.01633dc99a8f71b96264.js","sourcesContent":["import * as React from \"react\";\nimport UiStore from \"~/stores/UiStore\";\n\ntype Props = {\n  ui: UiStore;\n};\n\nclass HideSidebar extends React.Component<Props> {\n  componentDidMount() {\n    this.props.ui.enableEditMode();\n  }\n\n  componentWillUnmount() {\n    this.props.ui.disableEditMode();\n  }\n\n  render() {\n    return this.props.children || null;\n  }\n}\n\nexport default HideSidebar;\n","import invariant from \"invariant\";\nimport { observable } from \"mobx\";\nimport { observer } from \"mobx-react\";\nimport * as React from \"react\";\nimport { RouteComponentProps, StaticContext } from \"react-router\";\nimport RootStore from \"~/stores/RootStore\";\nimport Document from \"~/models/Document\";\nimport Revision from \"~/models/Revision\";\nimport Error404 from \"~/scenes/Error404\";\nimport ErrorOffline from \"~/scenes/ErrorOffline\";\nimport withStores from \"~/components/withStores\";\nimport { NavigationNode } from \"~/types\";\nimport { NotFoundError, OfflineError } from \"~/utils/errors\";\nimport history from \"~/utils/history\";\nimport { matchDocumentEdit } from \"~/utils/routeHelpers\";\nimport HideSidebar from \"./HideSidebar\";\nimport Loading from \"./Loading\";\n\ntype Props = RootStore &\n  RouteComponentProps<\n    {\n      documentSlug: string;\n      revisionId?: string;\n      shareId?: string;\n      title?: string;\n    },\n    StaticContext,\n    {\n      title?: string;\n    }\n  > & {\n    children: (arg0: any) => React.ReactNode;\n  };\n\n@observer\nclass DataLoader extends React.Component<Props> {\n  sharedTree: NavigationNode | null | undefined;\n\n  @observable\n  document: Document | null | undefined;\n\n  @observable\n  revision: Revision | null | undefined;\n\n  @observable\n  shapshot: Blob | null | undefined;\n\n  @observable\n  error: Error | null | undefined;\n\n  componentDidMount() {\n    const { documents, match } = this.props;\n    this.document = documents.getByUrl(match.params.documentSlug);\n    this.sharedTree = this.document\n      ? documents.getSharedTree(this.document.id)\n      : undefined;\n    this.loadDocument();\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    // If we have the document in the store, but not it's policy then we need to\n    // reload from the server otherwise the UI will not know which authorizations\n    // the user has\n    if (this.document) {\n      const document = this.document;\n      const policy = this.props.policies.get(document.id);\n\n      if (\n        !policy &&\n        !this.error &&\n        this.props.auth.user &&\n        this.props.auth.user.id\n      ) {\n        this.loadDocument();\n      }\n    }\n\n    // Also need to load the revision if it changes\n    const { revisionId } = this.props.match.params;\n\n    if (\n      prevProps.match.params.revisionId !== revisionId &&\n      revisionId &&\n      revisionId !== \"latest\"\n    ) {\n      this.loadRevision();\n    }\n  }\n\n  get isEditRoute() {\n    return this.props.match.path === matchDocumentEdit;\n  }\n\n  get isEditing() {\n    return this.isEditRoute || this.props.auth?.team?.collaborativeEditing;\n  }\n\n  onCreateLink = async (title: string) => {\n    const document = this.document;\n    invariant(document, \"document must be loaded to create link\");\n\n    const newDocument = await this.props.documents.create({\n      collectionId: document.collectionId,\n      parentDocumentId: document.parentDocumentId,\n      title,\n      text: \"\",\n    });\n\n    return newDocument.url;\n  };\n\n  loadRevision = async () => {\n    const { revisionId } = this.props.match.params;\n\n    if (revisionId) {\n      this.revision = await this.props.revisions.fetch(revisionId);\n    }\n  };\n\n  loadDocument = async () => {\n    const { shareId, documentSlug, revisionId } = this.props.match.params;\n\n    // sets the document as active in the sidebar if we already have it loaded\n    if (this.document) {\n      this.props.ui.setActiveDocument(this.document);\n    }\n\n    try {\n      const response = await this.props.documents.fetchWithSharedTree(\n        documentSlug,\n        {\n          shareId,\n        }\n      );\n      this.sharedTree = response.sharedTree;\n      this.document = response.document;\n\n      if (revisionId && revisionId !== \"latest\") {\n        await this.loadRevision();\n      } else {\n        this.revision = undefined;\n      }\n    } catch (err) {\n      this.error = err;\n      return;\n    }\n\n    const document = this.document;\n\n    if (document) {\n      const can = this.props.policies.abilities(document.id);\n      // sets the document as active in the sidebar, ideally in the future this\n      // will be route driven.\n      this.props.ui.setActiveDocument(document);\n\n      // If we're attempting to update an archived, deleted, or otherwise\n      // uneditable document then forward to the canonical read url.\n      if (!can.update && this.isEditRoute) {\n        history.push(document.url);\n        return;\n      }\n\n      // Prevents unauthorized request to load share information for the document\n      // when viewing a public share link\n      if (can.read) {\n        this.props.shares.fetch(document.id).catch((err) => {\n          if (!(err instanceof NotFoundError)) {\n            throw err;\n          }\n        });\n      }\n    }\n  };\n\n  render() {\n    const { location, policies, auth, match, ui } = this.props;\n    const { revisionId } = match.params;\n\n    if (this.error) {\n      return this.error instanceof OfflineError ? (\n        <ErrorOffline />\n      ) : (\n        <Error404 />\n      );\n    }\n\n    const team = auth.team;\n    const document = this.document;\n    const revision = this.revision;\n\n    if (!document || !team || (revisionId && !revision)) {\n      return (\n        <>\n          <Loading location={location} />\n          {this.isEditing && !team?.collaborativeEditing && (\n            <HideSidebar ui={ui} />\n          )}\n        </>\n      );\n    }\n\n    const abilities = policies.abilities(document.id);\n    // We do not want to remount the document when changing from view->edit\n    // on the multiplayer flag as the doc is guaranteed to be upto date.\n    const key = team.collaborativeEditing\n      ? \"\"\n      : this.isEditing\n      ? \"editing\"\n      : \"read-only\";\n\n    return (\n      <React.Fragment key={key}>\n        {this.isEditing && !team.collaborativeEditing && (\n          <HideSidebar ui={ui} />\n        )}\n        {this.props.children({\n          document,\n          revision,\n          abilities,\n          isEditing: this.isEditing,\n          readOnly:\n            !this.isEditing ||\n            !abilities.update ||\n            document.isArchived ||\n            !!revisionId,\n          onCreateLink: this.onCreateLink,\n          sharedTree: this.sharedTree,\n        })}\n      </React.Fragment>\n    );\n  }\n}\n\nexport default withStores(DataLoader);\n","import * as React from \"react\";\nimport { USER_PRESENCE_INTERVAL } from \"@shared/constants\";\nimport { SocketContext } from \"~/components/SocketProvider\";\n\ntype Props = {\n  documentId: string;\n  isEditing: boolean;\n};\n\nexport default class SocketPresence extends React.Component<Props> {\n  static contextType = SocketContext;\n\n  previousContext: typeof SocketContext;\n\n  editingInterval: ReturnType<typeof setInterval>;\n\n  componentDidMount() {\n    this.editingInterval = setInterval(() => {\n      if (this.props.isEditing) {\n        this.emitPresence();\n      }\n    }, USER_PRESENCE_INTERVAL);\n    this.setupOnce();\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    this.setupOnce();\n\n    if (prevProps.isEditing !== this.props.isEditing) {\n      this.emitPresence();\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.context) {\n      this.context.emit(\"leave\", {\n        documentId: this.props.documentId,\n      });\n      this.context.off(\"authenticated\", this.emitJoin);\n    }\n\n    clearInterval(this.editingInterval);\n  }\n\n  setupOnce = () => {\n    if (this.context && this.context !== this.previousContext) {\n      this.previousContext = this.context;\n\n      if (this.context.authenticated) {\n        this.emitJoin();\n      }\n\n      this.context.on(\"authenticated\", () => {\n        this.emitJoin();\n      });\n    }\n  };\n\n  emitJoin = () => {\n    if (!this.context) {\n      return;\n    }\n    this.context.emit(\"join\", {\n      documentId: this.props.documentId,\n      isEditing: this.props.isEditing,\n    });\n  };\n\n  emitPresence = () => {\n    if (!this.context) {\n      return;\n    }\n    this.context.emit(\"presence\", {\n      documentId: this.props.documentId,\n      isEditing: this.props.isEditing,\n    });\n  };\n\n  render() {\n    return this.props.children || null;\n  }\n}\n","import * as React from \"react\";\nimport { StaticContext } from \"react-router\";\nimport { RouteComponentProps } from \"react-router-dom\";\nimport useCurrentTeam from \"~/hooks/useCurrentTeam\";\nimport useStores from \"~/hooks/useStores\";\nimport DataLoader from \"./components/DataLoader\";\nimport Document from \"./components/Document\";\nimport SocketPresence from \"./components/SocketPresence\";\n\nexport default function DocumentScene(\n  props: RouteComponentProps<\n    { documentSlug: string; revisionId: string },\n    StaticContext,\n    { title?: string }\n  >\n) {\n  const { ui } = useStores();\n  const team = useCurrentTeam();\n  const { documentSlug, revisionId } = props.match.params;\n\n  React.useEffect(() => {\n    return () => ui.clearActiveDocument();\n  }, [ui]);\n\n  // the urlId portion of the url does not include the slugified title\n  // we only want to force a re-mount of the document component when the\n  // document changes, not when the title does so only this portion is used\n  // for the key.\n  const urlParts = documentSlug ? documentSlug.split(\"-\") : [];\n  const urlId = urlParts.length ? urlParts[urlParts.length - 1] : undefined;\n  const key = [urlId, revisionId].join(\"/\");\n  const isMultiplayer = team.collaborativeEditing;\n\n  return (\n    <DataLoader\n      key={key}\n      match={props.match}\n      history={props.history}\n      location={props.location}\n    >\n      {({ document, isEditing, ...rest }) => {\n        const isActive =\n          !document.isArchived && !document.isDeleted && !revisionId;\n\n        // TODO: Remove once multiplayer is 100% rollout, SocketPresence will\n        // no longer be required\n        if (isActive && !isMultiplayer) {\n          return (\n            <SocketPresence documentId={document.id} isEditing={isEditing}>\n              <Document document={document} match={props.match} {...rest} />\n            </SocketPresence>\n          );\n        }\n\n        return <Document document={document} match={props.match} {...rest} />;\n      }}\n    </DataLoader>\n  );\n}\n"],"sourceRoot":""}