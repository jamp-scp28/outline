{"version":3,"sources":["webpack:///./shared/editor/queries/isNodeActive.ts","webpack:///./shared/editor/types/index.ts","webpack:///./shared/editor/queries/isInList.ts","webpack:///./shared/editor/queries/getMarkRange.ts","webpack:///./shared/editor/lib/Extension.ts","webpack:///./shared/editor/lib/headingToSlug.ts","webpack:///./shared/editor/lib/markInputRule.ts","webpack:///./shared/editor/rules/mark.ts","webpack:///./shared/editor/marks/Mark.ts","webpack:///./shared/editor/marks/Highlight.ts","webpack:///./shared/editor/marks/Placeholder.ts","webpack:///./shared/editor/commands/toggleWrap.ts","webpack:///./shared/editor/components/Widget.tsx","webpack:///./shared/editor/rules/attachments.ts","webpack:///./shared/editor/nodes/Node.ts","webpack:///./shared/editor/nodes/Attachment.tsx","webpack:///./shared/editor/nodes/Blockquote.ts","webpack:///./shared/editor/queries/isList.ts","webpack:///./shared/editor/commands/clearNodes.ts","webpack:///./shared/editor/commands/toggleList.ts","webpack:///./shared/editor/lib/chainTransactions.ts","webpack:///./shared/editor/nodes/BulletList.ts","webpack:///./shared/editor/rules/checkboxes.ts","webpack:///./shared/editor/nodes/CheckboxItem.ts","webpack:///./shared/editor/nodes/CheckboxList.ts","webpack:///./shared/editor/commands/toggleBlockType.ts","webpack:///./shared/editor/plugins/Prism.ts","webpack:///./shared/editor/queries/isInCode.ts","webpack:///./shared/editor/nodes/CodeFence.ts","webpack:///./shared/editor/nodes/CodeBlock.ts","webpack:///./shared/editor/components/DisabledEmbed.tsx","webpack:///./shared/editor/rules/embeds.ts","webpack:///./shared/editor/nodes/Embed.tsx","webpack:///./shared/editor/commands/backspaceToParagraph.ts","webpack:///./shared/editor/queries/findCollapsedNodes.ts","webpack:///./shared/editor/commands/splitHeading.ts","webpack:///./shared/editor/nodes/Heading.ts","webpack:///./shared/editor/nodes/HorizontalRule.ts","webpack:///./shared/editor/queries/getParentListItem.ts","webpack:///./shared/editor/nodes/ListItem.ts","webpack:///./shared/editor/rules/notices.ts","webpack:///./shared/editor/nodes/Notice.tsx","webpack:///./shared/editor/nodes/OrderedList.ts","webpack:///./shared/editor/rules/tables.ts","webpack:///./shared/editor/nodes/Table.ts","webpack:///./shared/editor/nodes/TableCell.ts","webpack:///./shared/editor/nodes/TableHeadCell.ts","webpack:///./shared/editor/nodes/TableRow.ts","webpack:///./shared/editor/plugins/BlockMenuTrigger.tsx","webpack:///./shared/editor/plugins/Folding.tsx","webpack:///./shared/editor/plugins/Keys.ts","webpack:///./shared/editor/marks/Bold.ts","webpack:///./shared/editor/commands/moveLeft.ts","webpack:///./shared/editor/marks/Code.ts","webpack:///./shared/editor/commands/moveRight.ts","webpack:///./shared/editor/marks/Italic.ts","webpack:///./shared/editor/marks/Link.tsx","webpack:///./shared/editor/queries/findLinkNodes.ts","webpack:///./shared/editor/marks/Strikethrough.ts","webpack:///./shared/editor/rules/underlines.ts","webpack:///./shared/editor/marks/Underline.ts","webpack:///./shared/editor/nodes/Doc.ts","webpack:///./shared/editor/rules/emoji.ts","webpack:///./shared/editor/nodes/Emoji.tsx","webpack:///./shared/editor/rules/breaks.ts","webpack:///./shared/editor/nodes/HardBreak.ts","webpack:///./shared/editor/nodes/Image.tsx","webpack:///./shared/editor/nodes/Paragraph.ts","webpack:///./shared/editor/nodes/Text.ts","webpack:///./shared/editor/plugins/ClipboardTextSerializer.ts","webpack:///./shared/editor/lib/textBetween.ts","webpack:///./shared/editor/plugins/DateTime.ts","webpack:///./shared/editor/plugins/History.ts","webpack:///./shared/editor/plugins/MaxLength.ts","webpack:///./shared/editor/plugins/PasteHandler.ts","webpack:///./shared/editor/lib/isMarkdown.ts","webpack:///./shared/editor/plugins/Placeholder.ts","webpack:///./shared/editor/plugins/SmartText.ts","webpack:///./shared/editor/plugins/TrailingNode.ts","webpack:///./shared/editor/packages/full.ts","webpack:///./shared/editor/packages/basic.ts","webpack:///./shared/editor/queries/isMarkActive.ts","webpack:///./shared/editor/lib/isUrl.ts"],"names":["isNodeActive","type","attrs","state","node","findSelectedNodeOfType","selection","findParentNode","Object","keys","length","hasMarkup","EventType","isInList","$head","d","depth","includes","name","getMarkRange","$pos","start","parent","childAfter","parentOffset","mark","marks","find","startIndex","index","startPos","offset","endIndex","endPos","nodeSize","isInSet","child","childCount","from","to","Extension","options","this","defaultOptions","bindEditor","editor","get","_options","inputRules","commands","cache","Map","safeSlugify","text","has","slug","slugify","remove","lower","set","headingToSlug","slugified","textContent","headingToPersistenceKey","id","window","location","pathname","regexp","markType","getAttrs","InputRule","match","end","Function","tr","m","markEnd","markStart","matchStart","indexOf","matchEnd","textStart","lastIndexOf","textEnd","getMarksBetween","doc","nodesBetween","pos","map","filter","item","excludes","delete","addMark","create","removeStoredMark","delimCharCode","delim","charCodeAt","emphasisPlugin","md","postProcess","delimiters","j","startDelim","endDelim","token","i","loneMarkers","max","marker","tokens","tag","nesting","markup","content","push","pop","inline","ruler","before","tokenize","silent","src","scanned","scanDelims","ch","String","fromCharCode","len","can_open","can_close","jump","open","close","ruler2","curr","tokensMeta","tokens_meta","Mark","toMarkdown","console","error","parseMarkdown","toggleMark","Highlight","parseDOM","toDOM","markInputRule","markRule","mixable","expelEnclosingWhitespace","Placeholder","class","Plugin","props","handleTextInput","view","template","dispatch","$from","resolve","range","schema","placeholder","selectionStart","Math","min","selectionEnd","removeMark","insertText","$to","setSelection","TextSelection","near","handleKeyDown","event","editable","key","startOfMark","endOfMark","handleClick","target","HTMLSpanElement","className","stopPropagation","preventDefault","toggleWrap","lift","wrapIn","Widget","Wrapper","isSelected","href","rel","icon","Preview","Title","title","Subtitle","context","Children","children","styled","div","theme","strong","textTertiary","span","a","background","divider","css","secondaryBackground","isParagraph","isInline","isLinkOpen","isLinkClose","isAttachment","attrGet","startsWith","env","AWS_S3_UPLOAD_BUCKET_URL","AWS_S3_ACCELERATE_URL","linksToAttachments","core","after","insideLink","tokenChildren","current","Token","attrSet","parts","split","size","join","splice","Node","Attachment","attachmentsRule","default","group","defining","atom","priority","dom","innerText","getAttribute","parseInt","dataset","download","toPlainText","component","FileExtension","bytesToHumanReadable","Trans","color","ensureNewLine","write","tok","Blockquote","contentElement","wrappingInputRule","wrapBlock","undefined","renderContent","block","isList","nodes","bullet_list","ordered_list","checkbox_list","clearNodes","ranges","forEach","isText","mapping","$mappedFrom","$mappedTo","nodeRange","blockRange","targetLiftDepth","liftTarget","isTextblock","defaultType","contentMatchAt","setNodeMarkup","toggleList","listType","itemType","parentList","liftListItem","validContent","wrapInList","chainTransactions","dispatcher","apply","last","reduce","result","command","BulletList","list_item","renderList","bullet","CHECKBOX_REGEX","looksLikeChecklist","isListItem","matches","markdownItCheckbox","render","idx","checked","renderer","rules","checkbox_item_open","checkbox_item_close","toLowerCase","contentMatches","label","CheckboxItem","getBoundingClientRect","top","left","posAtCoords","transaction","inside","draggable","input","document","createElement","tabIndex","setAttribute","toString","addEventListener","contentEditable","checkboxRule","Enter","splitListItem","Tab","sinkListItem","CheckboxList","checkbox_item","toggleBlockType","toggleType","setBlockType","LANGUAGES","none","bash","clike","csharp","go","objectivec","java","javascript","json","perl","php","powershell","python","ruby","rust","sql","solidity","typescript","yaml","getDecorations","decorations","blocks","findBlockNodes","parseNodes","classNames","classes","properties","value","language","refractor","registered","eq","highlight","_decorations","Decoration","decoration","Number","DecorationSet","isInCode","code_block","isMarkActive","code_inline","PERSISTENCE_KEY","DEFAULT_LANGUAGE","register","CodeFence","handleCopyToClipboard","element","HTMLButtonElement","nodeAt","copy","onShowToast","dictionary","codeCopied","handleLanguageChange","currentTarget","HTMLSelectElement","Selection","localStorage","setItem","entries","code","preserveWhitespace","button","select","actions","appendChild","languageOptions","option","selected","spellCheck","paragraph","getItem","$anchor","nodeBefore","newText","splitByNewLine","numOfSpaces","search","repeat","highlighted","PluginKey","init","_","decorationSet","oldState","nodeName","previousNodeName","codeBlockChanged","docChanged","ySyncEdit","getMeta","setTimeout","setMeta","loaded","getState","textblockTypeInputRule","closeBlock","info","CodeBlock","DisabledEmbed","embed","replace","level","linksToEmbeds","embeds","isEmbed","link","matcher","markdownEmbeds","Embed","embedsRule","isEditable","embedsDisabled","hit","Component","e","replaceSelectionWith","scrollIntoView","esc","backspaceToParagraph","empty","findCollapsedNodes","withinCollapsedHeading","collapsed","splitHeading","allBlocks","collapsedBlocks","nextVisibleBlock","b","insert","Heading","handleFoldContent","hadFocus","hasFocus","endOfHeadingPos","persistKey","removeItem","focus","handleCopyLink","anchor","parentNode","previousSibling","Error","hash","urlWithoutHash","linkCopied","levels","fold","innerHTML","renderInline","slice","items","Backspace","getAnchors","previouslySeen","descendants","widget","side","plugin","config","RegExp","HorizontalRule","trim","replaceWith","getParentListItem","ListItem","newState","action","findParentNodeClosestToPos","list","order","listItemNumber","li","counterLength","add","hover","spec","handleDOMEvents","mouseover","closest","contains","posAtDOM","mouseout","log","newPos","nodeAfter","notice","customFence","validate","utils","escapeHtml","Notice","handleStyleChange","style","warning","tip","noticesRule","styleOptions","ReactDOM","OrderedList","hasAttribute","maxW","space","nStr","BREAK_REGEX","markdownTables","existing","breakParts","part","brToken","tokenAttrs","Table","tableRole","isolating","tablesRule","createTable","rowsCount","colsCount","resolvedPos","setColumnAttr","alignment","cells","getCellsInColumn","addColumnBefore","addColumnAfter","deleteColumn","addRowAfter","addRowAt","moveRow","deleteRow","deleteTable","toggleHeaderColumn","toggleHeaderRow","toggleHeaderCell","goToNextCell","isInTable","renderTable","tableEditing","table","getElementsByClassName","parentElement","scrollWidth","clientWidth","shadow","TableCell","colspan","rowspan","isTableSelected","grip","stopImmediatePropagation","selectTable","isRowSelected","selectRow","TableHeadCell","getCellsInRow","isColumnSelected","selectColumn","TableRow","OPEN_REGEX","CLOSE_REGEX","run","regex","handler","composing","textBefore","textBetween","exec","BlockMenuTrigger","events","emit","blockMenuClose","blockMenuOpen","isEmptyNode","isSlash","newLineEmpty","newLineWithSlash","Folding","appendTransaction","transactions","some","modified","Keys","onCancel","onSave","done","AllSelection","atStart","atEnd","GapCursor","heavyWeightRegex","normalWeightRegex","Bold","test","fontWeight","hasCode","backticksFor","ticks","Code","ArrowLeft","$cursor","storedMarks","insideCode","currentPosHasCode","nextPosHasCode","nextNextPosHasCode","exitingCode","Array","isArray","atLeftEdge","atRightEdge","enteringCode","addStoredMark","isFirstChild","ArrowRight","rangeHasMark","handlePaste","_event","replaceRange","_state","_mark","escape","Italic","LINK_INPUT_REGEX","isPlainURL","next","Link","inclusive","okay","alt","linkMenuOpen","getLinkDecorations","findLinkNodes","findTextNodes","nodeWithPos","linkMark","isExternalUrl","cloneNode","_oldState","HTMLAnchorElement","onHoverLink","mousedown","onClickHashtag","onClickLink","click","quote","Strikethrough","markdownUnderlines","Underline","underlinesRule","Doc","emoji","emojiPlugin","defs","no_name_mapping","nameToEmoji","shortcuts","Emoji","selectable","createTextNode","emojiRule","emojiMenuClose","emojiMenuOpen","position","isHardbreak","markdownBreakToParagraphs","count","isLast","HardBreak","breakRule","IMAGE_INPUT_REGEX","uploadPlugin","paste","uploadFile","clipboardData","files","prototype","call","dt","kind","getAsFile","Boolean","deleteSelection","insertFiles","drop","getDataTransferFiles","clientX","clientY","IMAGE_CLASSES","getLayoutAndTitle","tokenTitle","layoutClass","downloadImageNode","fetch","image","blob","imageBlob","imageURL","URL","createObjectURL","extension","potentialName","body","removeChild","Image","getPos","NodeSelection","handleBlur","handleSelect","handleDownload","handleMouseDown","ev","activeElement","onClick","onDownload","Caption","onKeyDown","onBlur","onMouseDown","role","suppressContentEditableWarning","data-caption","imageCaptionPlaceholder","img","getElementsByTagName","layoutClassMatched","markdown","downloadImage","deleteImage","alignRight","alignLeft","replaceImage","onFileUploadStart","onFileUploadStop","inputElement","accept","supportedImageMimeTypes","onchange","replaceExisting","alignCenter","createImage","matchedTitle","uploadPlaceholderPlugin","ImageComponent","React","width","setWidth","ImageWrapper","Button","onLoad","naturalWidth","defaultStyles","overlay","backgroundColor","shouldRespectMaxDimension","textSecondary","p","Paragraph","inTable","Text","ClipboardTextSerializer","textSerializers","fromEntries","clipboardTextSerializer","plainTextSerializers","separated","isBlock","DateTime","_match","getCurrentDateAsString","getCurrentTimeAsString","getCurrentDateTimeAsString","date","time","datetime","History","undo","redo","undoInputRule","history","MaxLength","filterTransaction","maxLength","isDropboxPaper","html","PasteHandler","transformPastedHTML","getData","vscode","isUrl","selectionIsInCode","vscodeMeta","JSON","parse","pasteCodeLanguage","mode","code_fence","isMarkdown","fences","listItems","pasteParser","normalizePastedMarkdown","replaceSelection","emptyNodeClass","completelyEmpty","rightArrow","SmartText","ellipsis","smartQuotes","TrailingNode","notAfter","disabledNodes","update","lastNode","lastChild","fullPackage","TemplatePlaceholder","hostname","err"],"mappings":"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","file":"default~document~shared-document~shared-editor.9d11aa4d63c54e508e2f.js","sourcesContent":["import { NodeType } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\nimport { findParentNode, findSelectedNodeOfType } from \"prosemirror-utils\";\n\nconst isNodeActive = (type: NodeType, attrs: Record<string, any> = {}) => (\n  state: EditorState\n) => {\n  if (!type) {\n    return false;\n  }\n\n  const node =\n    findSelectedNodeOfType(type)(state.selection) ||\n    findParentNode((node) => node.type === type)(state.selection);\n\n  if (!Object.keys(attrs).length || !node) {\n    return !!node;\n  }\n\n  return node.node.hasMarkup(type, { ...node.node.attrs, ...attrs });\n};\n\nexport default isNodeActive;\n","import { Node as ProsemirrorNode } from \"prosemirror-model\";\nimport { EditorState, Transaction } from \"prosemirror-state\";\nimport * as React from \"react\";\nimport { DefaultTheme } from \"styled-components\";\n\nexport type PlainTextSerializer = (node: ProsemirrorNode) => string;\n\nexport enum EventType {\n  blockMenuOpen = \"blockMenuOpen\",\n  blockMenuClose = \"blockMenuClose\",\n  emojiMenuOpen = \"emojiMenuOpen\",\n  emojiMenuClose = \"emojiMenuClose\",\n  linkMenuOpen = \"linkMenuOpen\",\n  linkMenuClose = \"linkMenuClose\",\n}\n\nexport type MenuItem = {\n  icon?: typeof React.Component | React.FC<any>;\n  name?: string;\n  title?: string;\n  shortcut?: string;\n  keywords?: string;\n  tooltip?: string;\n  defaultHidden?: boolean;\n  attrs?: Record<string, any>;\n  visible?: boolean;\n  active?: (state: EditorState) => boolean;\n};\n\nexport type EmbedDescriptor = MenuItem & {\n  icon: React.FC<any>;\n  matcher: (url: string) => boolean | [] | RegExpMatchArray;\n  component: typeof React.Component | React.FC<any>;\n};\n\nexport type ComponentProps = {\n  theme: DefaultTheme;\n  node: ProsemirrorNode;\n  isSelected: boolean;\n  isEditable: boolean;\n  getPos: () => number;\n};\n\nexport type Dispatch = (tr: Transaction) => void;\n","import { EditorState } from \"prosemirror-state\";\n\nexport default function isInList(state: EditorState) {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--) {\n    if (\n      [\"ordered_list\", \"bullet_list\", \"checkbox_list\"].includes(\n        $head.node(d).type.name\n      )\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import { ResolvedPos, MarkType } from \"prosemirror-model\";\n\nexport default function getMarkRange($pos?: ResolvedPos, type?: MarkType) {\n  if (!$pos || !type) {\n    return false;\n  }\n\n  const start = $pos.parent.childAfter($pos.parentOffset);\n  if (!start.node) {\n    return false;\n  }\n\n  const mark = start.node.marks.find((mark) => mark.type === type);\n  if (!mark) {\n    return false;\n  }\n\n  let startIndex = $pos.index();\n  let startPos = $pos.start() + start.offset;\n  let endIndex = startIndex + 1;\n  let endPos = startPos + start.node.nodeSize;\n\n  while (\n    startIndex > 0 &&\n    mark.isInSet($pos.parent.child(startIndex - 1).marks)\n  ) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n\n  while (\n    endIndex < $pos.parent.childCount &&\n    mark.isInSet($pos.parent.child(endIndex).marks)\n  ) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n\n  return { from: startPos, to: endPos, mark };\n}\n","import { PluginSimple } from \"markdown-it\";\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { NodeType, MarkType, Schema } from \"prosemirror-model\";\nimport { EditorState, Plugin } from \"prosemirror-state\";\nimport { EditorView } from \"prosemirror-view\";\nimport { Editor } from \"../../../app/editor\";\nimport { Dispatch } from \"../types\";\n\nexport type Command = (state: EditorState, dispatch: Dispatch) => boolean;\n\nexport type CommandFactory = (\n  attrs?: Record<string, any>\n) => (state: EditorState, dispatch: Dispatch, view: EditorView) => boolean;\n\nexport default class Extension {\n  options: any;\n  editor: Editor;\n\n  constructor(options: Record<string, any> = {}) {\n    this.options = {\n      ...this.defaultOptions,\n      ...options,\n    };\n  }\n\n  bindEditor(editor: Editor) {\n    this.editor = editor;\n  }\n\n  get type() {\n    return \"extension\";\n  }\n\n  get name() {\n    return \"\";\n  }\n\n  get plugins(): Plugin[] {\n    return [];\n  }\n\n  get rulePlugins(): PluginSimple[] {\n    return [];\n  }\n\n  get defaultOptions() {\n    return {};\n  }\n\n  keys(_options: {\n    type?: NodeType | MarkType;\n    schema: Schema;\n  }): Record<string, Command> {\n    return {};\n  }\n\n  inputRules(_options: {\n    type?: NodeType | MarkType;\n    schema: Schema;\n  }): InputRule[] {\n    return [];\n  }\n\n  commands(_options: {\n    type?: NodeType | MarkType;\n    schema: Schema;\n  }): Record<string, CommandFactory> | CommandFactory {\n    return {};\n  }\n}\n","import { escape } from \"lodash\";\nimport { Node } from \"prosemirror-model\";\nimport slugify from \"slugify\";\n\nconst cache = new Map<string, string>();\n\n// Slugify, escape, and remove periods from headings so that they are\n// compatible with both url hashes AND dom ID's (querySelector does not like\n// ID's that begin with a number or a period, for example).\nfunction safeSlugify(text: string) {\n  if (cache.has(text)) {\n    return cache.get(text) as string;\n  }\n\n  const slug = `h-${escape(\n    slugify(text, {\n      remove: /[!\"#$%&'\\.()*+,\\/:;<=>?@\\[\\]\\\\^_`{|}~]/g,\n      lower: true,\n    })\n  )}`;\n\n  cache.set(text, slug);\n  return slug;\n}\n\n// calculates a unique slug for this heading based on it's text and position\n// in the document that is as stable as possible\nexport default function headingToSlug(node: Node, index = 0) {\n  const slugified = safeSlugify(node.textContent);\n  if (index === 0) {\n    return slugified;\n  }\n  return `${slugified}-${index}`;\n}\n\nexport function headingToPersistenceKey(node: Node, id?: string) {\n  const slug = headingToSlug(node);\n  return `rme-${id || window?.location.pathname}–${slug}`;\n}\n","import { InputRule } from \"prosemirror-inputrules\";\nimport { MarkType, Mark } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\n\nfunction getMarksBetween(start: number, end: number, state: EditorState) {\n  let marks: { start: number; end: number; mark: Mark }[] = [];\n\n  state.doc.nodesBetween(start, end, (node, pos) => {\n    marks = [\n      ...marks,\n      ...node.marks.map((mark) => ({\n        start: pos,\n        end: pos + node.nodeSize,\n        mark,\n      })),\n    ];\n  });\n\n  return marks;\n}\n\nexport default function (\n  regexp: RegExp,\n  markType: MarkType,\n  getAttrs?: (match: string[]) => Record<string, unknown>\n): InputRule {\n  return new InputRule(\n    regexp,\n    (state: EditorState, match: string[], start: number, end: number) => {\n      const attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n      const { tr } = state;\n      const m = match.length - 1;\n      let markEnd = end;\n      let markStart = start;\n\n      if (match[m]) {\n        const matchStart = start + match[0].indexOf(match[m - 1]);\n        const matchEnd = matchStart + match[m - 1].length - 1;\n        const textStart = matchStart + match[m - 1].lastIndexOf(match[m]);\n        const textEnd = textStart + match[m].length;\n\n        const excludedMarks = getMarksBetween(start, end, state)\n          .filter((item) => item.mark.type.excludes(markType))\n          .filter((item) => item.end > matchStart);\n\n        if (excludedMarks.length) {\n          return null;\n        }\n\n        if (textEnd < matchEnd) {\n          tr.delete(textEnd, matchEnd);\n        }\n        if (textStart > matchStart) {\n          tr.delete(matchStart, textStart);\n        }\n        markStart = matchStart;\n        markEnd = markStart + match[m].length;\n      }\n\n      tr.addMark(markStart, markEnd, markType.create(attrs));\n      tr.removeStoredMark(markType);\n      return tr;\n    }\n  );\n}\n","// Adapted from:\n// https://github.com/markdown-it/markdown-it-mark/blob/master/index.js\n\nimport MarkdownIt from \"markdown-it\";\nimport StateInline from \"markdown-it/lib/rules_inline/state_inline\";\n\nexport default function (options: { delim: string; mark: string }) {\n  const delimCharCode = options.delim.charCodeAt(0);\n\n  return function emphasisPlugin(md: MarkdownIt) {\n    function tokenize(state: StateInline, silent: boolean) {\n      let i, token;\n\n      const start = state.pos,\n        marker = state.src.charCodeAt(start);\n\n      if (silent) {\n        return false;\n      }\n\n      if (marker !== delimCharCode) {\n        return false;\n      }\n\n      const scanned = state.scanDelims(state.pos, true);\n      const ch = String.fromCharCode(marker);\n      let len = scanned.length;\n\n      if (len < 2) {\n        return false;\n      }\n\n      if (len % 2) {\n        token = state.push(\"text\", \"\", 0);\n        token.content = ch;\n        len--;\n      }\n\n      for (i = 0; i < len; i += 2) {\n        token = state.push(\"text\", \"\", 0);\n        token.content = ch + ch;\n\n        if (!scanned.can_open && !scanned.can_close) {\n          continue;\n        }\n\n        state.delimiters.push({\n          marker,\n          length: 0, // disable \"rule of 3\" length checks meant for emphasis\n          jump: i,\n          token: state.tokens.length - 1,\n          end: -1,\n          open: scanned.can_open,\n          close: scanned.can_close,\n        });\n      }\n\n      state.pos += scanned.length;\n      return true;\n    }\n\n    // Walk through delimiter list and replace text tokens with tags\n    //\n    function postProcess(\n      state: StateInline,\n      delimiters: StateInline.Delimiter[]\n    ) {\n      let i = 0,\n        j,\n        startDelim,\n        endDelim,\n        token;\n      const loneMarkers: number[] = [],\n        max = delimiters.length;\n\n      for (i = 0; i < max; i++) {\n        startDelim = delimiters[i];\n\n        if (startDelim.marker !== delimCharCode) {\n          continue;\n        }\n\n        if (startDelim.end === -1) {\n          continue;\n        }\n\n        endDelim = delimiters[startDelim.end];\n\n        token = state.tokens[startDelim.token];\n        token.type = `${options.mark}_open`;\n        token.tag = \"span\";\n        token.attrs = [[\"class\", options.mark]];\n        token.nesting = 1;\n        token.markup = options.delim;\n        token.content = \"\";\n\n        token = state.tokens[endDelim.token];\n        token.type = `${options.mark}_close`;\n        token.tag = \"span\";\n        token.nesting = -1;\n        token.markup = options.delim;\n        token.content = \"\";\n\n        if (\n          state.tokens[endDelim.token - 1].type === \"text\" &&\n          state.tokens[endDelim.token - 1].content === options.delim[0]\n        ) {\n          loneMarkers.push(endDelim.token - 1);\n        }\n      }\n\n      // If a marker sequence has an odd number of characters, it's split\n      // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n      // start of the sequence.\n      //\n      // So, we have to move all those markers after subsequent s_close tags.\n      while (loneMarkers.length) {\n        i = loneMarkers.pop() as number;\n        j = i + 1;\n\n        while (\n          j < state.tokens.length &&\n          state.tokens[j].type === `${options.mark}_close`\n        ) {\n          j++;\n        }\n\n        j--;\n\n        if (i !== j) {\n          token = state.tokens[j];\n          state.tokens[j] = state.tokens[i];\n          state.tokens[i] = token;\n        }\n      }\n    }\n\n    md.inline.ruler.before(\"emphasis\", options.mark, tokenize);\n    md.inline.ruler2.before(\"emphasis\", options.mark, function (state) {\n      let curr;\n      const tokensMeta = state.tokens_meta,\n        max = (state.tokens_meta || []).length;\n\n      postProcess(state, state.delimiters);\n\n      for (curr = 0; curr < max; curr++) {\n        const delimiters = tokensMeta[curr]?.delimiters;\n        if (tokensMeta[curr] && delimiters) {\n          postProcess(state, delimiters);\n        }\n      }\n\n      return false;\n    });\n  };\n}\n","import { toggleMark } from \"prosemirror-commands\";\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { TokenConfig } from \"prosemirror-markdown\";\nimport {\n  MarkSpec,\n  MarkType,\n  Node as ProsemirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport Extension, { Command, CommandFactory } from \"../lib/Extension\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\n\nexport default abstract class Mark extends Extension {\n  get type() {\n    return \"mark\";\n  }\n\n  get schema(): MarkSpec {\n    return {};\n  }\n\n  get markdownToken(): string {\n    return \"\";\n  }\n\n  keys(_options: { type: MarkType; schema: Schema }): Record<string, Command> {\n    return {};\n  }\n\n  inputRules(_options: { type: MarkType; schema: Schema }): InputRule[] {\n    return [];\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    console.error(\"toMarkdown not implemented\", state, node);\n  }\n\n  parseMarkdown(): TokenConfig | void {\n    return undefined;\n  }\n\n  commands({ type }: { type: MarkType; schema: Schema }): CommandFactory {\n    return () => toggleMark(type);\n  }\n}\n","import { toggleMark } from \"prosemirror-commands\";\nimport { MarkSpec, MarkType } from \"prosemirror-model\";\nimport markInputRule from \"../lib/markInputRule\";\nimport markRule from \"../rules/mark\";\nimport Mark from \"./Mark\";\n\nexport default class Highlight extends Mark {\n  get name() {\n    return \"highlight\";\n  }\n\n  get schema(): MarkSpec {\n    return {\n      parseDOM: [{ tag: \"mark\" }],\n      toDOM: () => [\"mark\"],\n    };\n  }\n\n  inputRules({ type }: { type: MarkType }) {\n    return [markInputRule(/(?:==)([^=]+)(?:==)$/, type)];\n  }\n\n  keys({ type }: { type: MarkType }) {\n    return {\n      \"Mod-Ctrl-h\": toggleMark(type),\n    };\n  }\n\n  get rulePlugins() {\n    return [markRule({ delim: \"==\", mark: \"highlight\" })];\n  }\n\n  toMarkdown() {\n    return {\n      open: \"==\",\n      close: \"==\",\n      mixable: true,\n      expelEnclosingWhitespace: true,\n    };\n  }\n\n  parseMarkdown() {\n    return { mark: \"highlight\" };\n  }\n}\n","import { MarkSpec } from \"prosemirror-model\";\nimport { Plugin, TextSelection } from \"prosemirror-state\";\nimport getMarkRange from \"../queries/getMarkRange\";\nimport markRule from \"../rules/mark\";\nimport Mark from \"./Mark\";\n\nexport default class Placeholder extends Mark {\n  get name() {\n    return \"placeholder\";\n  }\n\n  get schema(): MarkSpec {\n    return {\n      parseDOM: [{ tag: \"span.template-placeholder\" }],\n      toDOM: () => [\"span\", { class: \"template-placeholder\" }],\n    };\n  }\n\n  get rulePlugins() {\n    return [markRule({ delim: \"!!\", mark: \"placeholder\" })];\n  }\n\n  toMarkdown() {\n    return {\n      open: \"!!\",\n      close: \"!!\",\n      mixable: true,\n      expelEnclosingWhitespace: true,\n    };\n  }\n\n  parseMarkdown() {\n    return { mark: \"placeholder\" };\n  }\n\n  get plugins() {\n    return [\n      new Plugin({\n        props: {\n          handleTextInput: (view, from, to, text) => {\n            if (this.editor.props.template) {\n              return false;\n            }\n\n            const { state, dispatch } = view;\n            const $from = state.doc.resolve(from);\n\n            const range = getMarkRange($from, state.schema.marks.placeholder);\n            if (!range) {\n              return false;\n            }\n\n            const selectionStart = Math.min(from, range.from);\n            const selectionEnd = Math.max(to, range.to);\n\n            dispatch(\n              state.tr\n                .removeMark(\n                  range.from,\n                  range.to,\n                  state.schema.marks.placeholder\n                )\n                .insertText(text, selectionStart, selectionEnd)\n            );\n\n            const $to = view.state.doc.resolve(selectionStart + text.length);\n            dispatch(view.state.tr.setSelection(TextSelection.near($to)));\n\n            return true;\n          },\n          handleKeyDown: (view, event: KeyboardEvent) => {\n            if (!view.props.editable || !view.props.editable(view.state)) {\n              return false;\n            }\n            if (this.editor.props.template) {\n              return false;\n            }\n            if (\n              event.key !== \"ArrowLeft\" &&\n              event.key !== \"ArrowRight\" &&\n              event.key !== \"Backspace\"\n            ) {\n              return false;\n            }\n\n            const { state, dispatch } = view;\n\n            if (event.key === \"Backspace\") {\n              const range = getMarkRange(\n                state.doc.resolve(Math.max(0, state.selection.from - 1)),\n                state.schema.marks.placeholder\n              );\n              if (!range) {\n                return false;\n              }\n\n              dispatch(\n                state.tr\n                  .removeMark(\n                    range.from,\n                    range.to,\n                    state.schema.marks.placeholder\n                  )\n                  .insertText(\"\", range.from, range.to)\n              );\n              return true;\n            }\n\n            if (event.key === \"ArrowLeft\") {\n              const range = getMarkRange(\n                state.doc.resolve(Math.max(0, state.selection.from - 1)),\n                state.schema.marks.placeholder\n              );\n              if (!range) {\n                return false;\n              }\n\n              const startOfMark = state.doc.resolve(range.from);\n              dispatch(state.tr.setSelection(TextSelection.near(startOfMark)));\n              return true;\n            }\n\n            if (event.key === \"ArrowRight\") {\n              const range = getMarkRange(\n                state.selection.$from,\n                state.schema.marks.placeholder\n              );\n              if (!range) {\n                return false;\n              }\n\n              const endOfMark = state.doc.resolve(range.to);\n              dispatch(state.tr.setSelection(TextSelection.near(endOfMark)));\n              return true;\n            }\n\n            return false;\n          },\n          handleClick: (view, pos, event: MouseEvent) => {\n            if (!view.props.editable || !view.props.editable(view.state)) {\n              return false;\n            }\n            if (this.editor.props.template) {\n              return false;\n            }\n\n            if (\n              event.target instanceof HTMLSpanElement &&\n              event.target.className.includes(\"template-placeholder\")\n            ) {\n              const { state, dispatch } = view;\n              const range = getMarkRange(\n                state.selection.$from,\n                state.schema.marks.placeholder\n              );\n              if (!range) {\n                return false;\n              }\n\n              event.stopPropagation();\n              event.preventDefault();\n              const startOfMark = state.doc.resolve(range.from);\n              dispatch(state.tr.setSelection(TextSelection.near(startOfMark)));\n\n              return true;\n            }\n            return false;\n          },\n        },\n      }),\n    ];\n  }\n}\n","import { wrapIn, lift } from \"prosemirror-commands\";\nimport { NodeType } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\nimport isNodeActive from \"../queries/isNodeActive\";\nimport { Dispatch } from \"../types\";\n\nexport default function toggleWrap(\n  type: NodeType,\n  attrs?: Record<string, any>\n) {\n  return (state: EditorState, dispatch?: Dispatch) => {\n    const isActive = isNodeActive(type)(state);\n\n    if (isActive) {\n      return lift(state, dispatch);\n    }\n\n    return wrapIn(type, attrs)(state, dispatch);\n  };\n}\n","import * as React from \"react\";\nimport styled, { css, DefaultTheme, ThemeProps } from \"styled-components\";\n\ntype Props = {\n  icon: React.ReactNode;\n  title: React.ReactNode;\n  context?: React.ReactNode;\n  href: string;\n  isSelected: boolean;\n  children?: React.ReactNode;\n};\n\nexport default function Widget(props: Props & ThemeProps<DefaultTheme>) {\n  return (\n    <Wrapper\n      className={\n        props.isSelected ? \"ProseMirror-selectednode widget\" : \"widget\"\n      }\n      href={props.href}\n      target=\"_blank\"\n      rel=\"noreferrer nofollow\"\n    >\n      {props.icon}\n      <Preview>\n        <Title>{props.title}</Title>\n        <Subtitle>{props.context}</Subtitle>\n        <Children>{props.children}</Children>\n      </Preview>\n    </Wrapper>\n  );\n}\n\nconst Children = styled.div`\n  margin-left: auto;\n  height: 20px;\n  opacity: 0;\n\n  &:hover {\n    color: ${(props) => props.theme.text};\n  }\n`;\n\nconst Title = styled.strong`\n  font-weight: 500;\n  font-size: 14px;\n  color: ${(props) => props.theme.text};\n`;\n\nconst Preview = styled.div`\n  gap: 8px;\n  display: flex;\n  flex-direction: row;\n  flex-grow: 1;\n  align-items: center;\n  color: ${(props) => props.theme.textTertiary};\n`;\n\nconst Subtitle = styled.span`\n  font-size: 13px;\n  color: ${(props) => props.theme.textTertiary} !important;\n  line-height: 0;\n`;\n\nconst Wrapper = styled.a`\n  display: flex;\n  align-items: center;\n  gap: 6px;\n  background: ${(props) => props.theme.background};\n  color: ${(props) => props.theme.text} !important;\n  box-shadow: 0 0 0 1px ${(props) => props.theme.divider};\n  white-space: nowrap;\n  border-radius: 8px;\n  padding: 6px 8px;\n  max-width: 840px;\n  cursor: default;\n\n  user-select: none;\n  text-overflow: ellipsis;\n  overflow: hidden;\n\n  ${(props) =>\n    props.href &&\n    css`\n      &:hover,\n      &:active {\n        cursor: pointer !important;\n        text-decoration: none !important;\n        background: ${(props) => props.theme.secondaryBackground};\n\n        ${Children} {\n          opacity: 1;\n        }\n      }\n    `}\n`;\n","import MarkdownIt from \"markdown-it\";\nimport Token from \"markdown-it/lib/token\";\nimport env from \"../../env\";\n\nfunction isParagraph(token: Token) {\n  return token.type === \"paragraph_open\";\n}\n\nfunction isInline(token: Token) {\n  return token.type === \"inline\";\n}\n\nfunction isLinkOpen(token: Token) {\n  return token.type === \"link_open\";\n}\n\nfunction isLinkClose(token: Token) {\n  return token.type === \"link_close\";\n}\n\nfunction isAttachment(token: Token) {\n  const href = token.attrGet(\"href\");\n  return (\n    // internal\n    href?.startsWith(\"/api/attachments.redirect\") ||\n    // external (public share are pre-signed and this is a reasonable way of detecting them)\n    ((href?.startsWith(env.AWS_S3_UPLOAD_BUCKET_URL) ||\n      href?.startsWith(env.AWS_S3_ACCELERATE_URL)) &&\n      href?.includes(\"X-Amz-Signature\"))\n  );\n}\n\nexport default function linksToAttachments(md: MarkdownIt) {\n  md.core.ruler.after(\"breaks\", \"attachments\", (state) => {\n    const tokens = state.tokens;\n    let insideLink;\n\n    for (let i = 0; i < tokens.length - 1; i++) {\n      // once we find an inline token look through it's children for links\n      if (isInline(tokens[i]) && isParagraph(tokens[i - 1])) {\n        const tokenChildren = tokens[i].children || [];\n\n        for (let j = 0; j < tokenChildren.length - 1; j++) {\n          const current = tokenChildren[j];\n          if (!current) {\n            continue;\n          }\n\n          if (isLinkOpen(current)) {\n            insideLink = current;\n            continue;\n          }\n\n          if (isLinkClose(current)) {\n            insideLink = null;\n            continue;\n          }\n\n          // of hey, we found a link – lets check to see if it should be\n          // converted to a file attachment\n          if (insideLink && isAttachment(insideLink)) {\n            const { content } = current;\n\n            // convert to attachment token\n            const token = new Token(\"attachment\", \"a\", 0);\n            token.attrSet(\"href\", insideLink.attrGet(\"href\") || \"\");\n\n            const parts = content.split(\" \");\n            const size = parts.pop();\n            const title = parts.join(\" \");\n            token.attrSet(\"size\", size || \"0\");\n            token.attrSet(\"title\", title);\n\n            // delete the inline link – this makes the assumption that the\n            // attachment is the only thing in the para.\n            tokens.splice(i - 1, 3, token);\n            insideLink = null;\n            break;\n          }\n        }\n      }\n    }\n\n    return false;\n  });\n}\n","import { InputRule } from \"prosemirror-inputrules\";\nimport { TokenConfig } from \"prosemirror-markdown\";\nimport {\n  NodeSpec,\n  Node as ProsemirrorNode,\n  NodeType,\n  Schema,\n} from \"prosemirror-model\";\nimport Extension, { Command, CommandFactory } from \"../lib/Extension\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\n\nexport default abstract class Node extends Extension {\n  get type() {\n    return \"node\";\n  }\n\n  get schema(): NodeSpec {\n    return {};\n  }\n\n  get markdownToken(): string {\n    return \"\";\n  }\n\n  inputRules(_options: { type: NodeType; schema: Schema }): InputRule[] {\n    return [];\n  }\n\n  keys(_options: { type: NodeType; schema: Schema }): Record<string, Command> {\n    return {};\n  }\n\n  commands(_options: {\n    type: NodeType;\n    schema: Schema;\n  }): Record<string, CommandFactory> | CommandFactory {\n    return {};\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode): void {\n    console.error(\"toMarkdown not implemented\", state, node);\n  }\n\n  parseMarkdown(): TokenConfig | void {\n    return undefined;\n  }\n}\n","import Token from \"markdown-it/lib/token\";\nimport { DownloadIcon } from \"outline-icons\";\nimport { NodeSpec, NodeType, Node as ProsemirrorNode } from \"prosemirror-model\";\nimport * as React from \"react\";\nimport { Trans } from \"react-i18next\";\nimport { bytesToHumanReadable } from \"../../utils/files\";\nimport toggleWrap from \"../commands/toggleWrap\";\nimport FileExtension from \"../components/FileExtension\";\nimport Widget from \"../components/Widget\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport attachmentsRule from \"../rules/attachments\";\nimport { ComponentProps } from \"../types\";\nimport Node from \"./Node\";\n\nexport default class Attachment extends Node {\n  get name() {\n    return \"attachment\";\n  }\n\n  get rulePlugins() {\n    return [attachmentsRule];\n  }\n\n  get schema(): NodeSpec {\n    return {\n      attrs: {\n        id: {\n          default: null,\n        },\n        href: {\n          default: null,\n        },\n        title: {},\n        size: {},\n      },\n      group: \"block\",\n      defining: true,\n      atom: true,\n      parseDOM: [\n        {\n          priority: 100,\n          tag: \"a.attachment\",\n          getAttrs: (dom: HTMLAnchorElement) => {\n            return {\n              id: dom.id,\n              title: dom.innerText,\n              href: dom.getAttribute(\"href\"),\n              size: parseInt(dom.dataset.size || \"0\", 10),\n            };\n          },\n        },\n      ],\n      toDOM: (node) => {\n        return [\n          \"a\",\n          {\n            class: `attachment`,\n            id: node.attrs.id,\n            href: node.attrs.href,\n            download: node.attrs.title,\n            \"data-size\": node.attrs.size,\n          },\n          node.attrs.title,\n        ];\n      },\n      toPlainText: (node) => node.attrs.title,\n    };\n  }\n\n  component({ isSelected, theme, node }: ComponentProps) {\n    return (\n      <Widget\n        icon={<FileExtension title={node.attrs.title} />}\n        href={node.attrs.href}\n        title={node.attrs.title}\n        context={\n          node.attrs.href ? (\n            bytesToHumanReadable(node.attrs.size)\n          ) : (\n            <>\n              <Trans>Uploading</Trans>…\n            </>\n          )\n        }\n        isSelected={isSelected}\n        theme={theme}\n      >\n        {node.attrs.href && <DownloadIcon color=\"currentColor\" size={20} />}\n      </Widget>\n    );\n  }\n\n  commands({ type }: { type: NodeType }) {\n    return (attrs: Record<string, any>) => toggleWrap(type, attrs);\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    state.ensureNewLine();\n    state.write(\n      `[${node.attrs.title} ${node.attrs.size}](${node.attrs.href})\\n\\n`\n    );\n    state.ensureNewLine();\n  }\n\n  parseMarkdown() {\n    return {\n      node: \"attachment\",\n      getAttrs: (tok: Token) => ({\n        href: tok.attrGet(\"href\"),\n        title: tok.attrGet(\"title\"),\n        size: tok.attrGet(\"size\"),\n      }),\n    };\n  }\n}\n","import { wrappingInputRule } from \"prosemirror-inputrules\";\nimport { NodeSpec, Node as ProsemirrorNode, NodeType } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\nimport toggleWrap from \"../commands/toggleWrap\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport isNodeActive from \"../queries/isNodeActive\";\nimport { Dispatch } from \"../types\";\nimport Node from \"./Node\";\n\nexport default class Blockquote extends Node {\n  get name() {\n    return \"blockquote\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      content: \"block+\",\n      group: \"block\",\n      defining: true,\n      parseDOM: [\n        { tag: \"blockquote\" },\n        // Dropbox Paper parsing, yes their quotes are actually lists\n        { tag: \"ul.listtype-quote\", contentElement: \"li\" },\n      ],\n      toDOM: () => [\"blockquote\", 0],\n    };\n  }\n\n  inputRules({ type }: { type: NodeType }) {\n    return [wrappingInputRule(/^\\s*>\\s$/, type)];\n  }\n\n  commands({ type }: { type: NodeType }) {\n    return () => toggleWrap(type);\n  }\n\n  keys({ type }: { type: NodeType }) {\n    return {\n      \"Ctrl->\": toggleWrap(type),\n      \"Mod-]\": toggleWrap(type),\n      \"Shift-Enter\": (state: EditorState, dispatch: Dispatch) => {\n        if (!isNodeActive(type)(state)) {\n          return false;\n        }\n\n        const { tr, selection } = state;\n        dispatch(tr.split(selection.to));\n        return true;\n      },\n    };\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    state.wrapBlock(\"> \", undefined, node, () => state.renderContent(node));\n  }\n\n  parseMarkdown() {\n    return { block: \"blockquote\" };\n  }\n}\n","import { Node, Schema } from \"prosemirror-model\";\n\nexport default function isList(node: Node, schema: Schema) {\n  return (\n    node.type === schema.nodes.bullet_list ||\n    node.type === schema.nodes.ordered_list ||\n    node.type === schema.nodes.checkbox_list\n  );\n}\n","import { EditorState } from \"prosemirror-state\";\nimport { liftTarget } from \"prosemirror-transform\";\nimport { Dispatch } from \"../types\";\n\nconst clearNodes = () => (state: EditorState, dispatch?: Dispatch) => {\n  const { tr } = state;\n  const { selection } = tr;\n  const { ranges } = selection;\n\n  if (!dispatch) {\n    return true;\n  }\n\n  ranges.forEach(({ $from, $to }) => {\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return;\n      }\n\n      const { doc, mapping } = tr;\n      const $mappedFrom = doc.resolve(mapping.map(pos));\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n      const nodeRange = $mappedFrom.blockRange($mappedTo);\n\n      if (!nodeRange) {\n        return;\n      }\n\n      const targetLiftDepth = liftTarget(nodeRange);\n\n      if (node.type.isTextblock) {\n        const { defaultType } = $mappedFrom.parent.contentMatchAt(\n          $mappedFrom.index()\n        );\n\n        tr.setNodeMarkup(nodeRange.start, defaultType);\n      }\n\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth);\n      }\n    });\n  });\n\n  dispatch(tr);\n  return true;\n};\n\nexport default clearNodes;\n","import { NodeType } from \"prosemirror-model\";\nimport { wrapInList, liftListItem } from \"prosemirror-schema-list\";\nimport { EditorState } from \"prosemirror-state\";\nimport { findParentNode } from \"prosemirror-utils\";\nimport chainTransactions from \"../lib/chainTransactions\";\nimport isList from \"../queries/isList\";\nimport { Dispatch } from \"../types\";\nimport clearNodes from \"./clearNodes\";\n\nexport default function toggleList(listType: NodeType, itemType: NodeType) {\n  return (state: EditorState, dispatch?: Dispatch) => {\n    const { schema, selection } = state;\n    const { $from, $to } = selection;\n    const range = $from.blockRange($to);\n    const { tr } = state;\n\n    if (!range) {\n      return false;\n    }\n\n    const parentList = findParentNode((node) => isList(node, schema))(\n      selection\n    );\n\n    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n      if (parentList.node.type === listType) {\n        return liftListItem(itemType)(state, dispatch);\n      }\n\n      if (\n        isList(parentList.node, schema) &&\n        listType.validContent(parentList.node.content)\n      ) {\n        tr.setNodeMarkup(parentList.pos, listType);\n\n        if (dispatch) {\n          dispatch(tr);\n        }\n\n        return false;\n      }\n    }\n\n    const canWrapInList = wrapInList(listType)(state);\n\n    if (canWrapInList) {\n      return wrapInList(listType)(state, dispatch);\n    }\n\n    return chainTransactions(clearNodes(), wrapInList(listType))(\n      state,\n      dispatch\n    );\n  };\n}\n","import { EditorState, Transaction } from \"prosemirror-state\";\nimport { Dispatch } from \"../types\";\n\nexport default function chainTransactions(\n  ...commands: ((state: EditorState, dispatch?: Dispatch) => boolean)[]\n) {\n  return (state: EditorState, dispatch?: Dispatch): boolean => {\n    const dispatcher = (tr: Transaction): void => {\n      state = state.apply(tr);\n      dispatch?.(tr);\n    };\n    const last = commands.pop();\n    const reduced = commands.reduce((result, command) => {\n      return result || command(state, dispatcher);\n    }, false);\n    return reduced && last !== undefined && last(state, dispatch);\n  };\n}\n","import { wrappingInputRule } from \"prosemirror-inputrules\";\nimport {\n  Schema,\n  NodeType,\n  NodeSpec,\n  Node as ProsemirrorModel,\n} from \"prosemirror-model\";\nimport toggleList from \"../commands/toggleList\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport Node from \"./Node\";\n\nexport default class BulletList extends Node {\n  get name() {\n    return \"bullet_list\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      content: \"list_item+\",\n      group: \"block\",\n      parseDOM: [{ tag: \"ul\" }],\n      toDOM: () => [\"ul\", 0],\n    };\n  }\n\n  commands({ type, schema }: { type: NodeType; schema: Schema }) {\n    return () => toggleList(type, schema.nodes.list_item);\n  }\n\n  keys({ type, schema }: { type: NodeType; schema: Schema }) {\n    return {\n      \"Shift-Ctrl-8\": toggleList(type, schema.nodes.list_item),\n    };\n  }\n\n  inputRules({ type }: { type: NodeType }) {\n    return [wrappingInputRule(/^\\s*([-+*])\\s$/, type)];\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorModel) {\n    state.renderList(node, \"  \", () => (node.attrs.bullet || \"*\") + \" \");\n  }\n\n  parseMarkdown() {\n    return { block: \"bullet_list\" };\n  }\n}\n","import MarkdownIt from \"markdown-it\";\nimport Token from \"markdown-it/lib/token\";\n\nconst CHECKBOX_REGEX = /\\[(X|\\s|_|-)\\]\\s(.*)?/i;\n\nfunction matches(token: Token | void) {\n  return token && token.content.match(CHECKBOX_REGEX);\n}\n\nfunction isInline(token: Token | void): boolean {\n  return !!token && token.type === \"inline\";\n}\n\nfunction isParagraph(token: Token | void): boolean {\n  return !!token && token.type === \"paragraph_open\";\n}\n\nfunction isListItem(token: Token | void): boolean {\n  return (\n    !!token &&\n    (token.type === \"list_item_open\" || token.type === \"checkbox_item_open\")\n  );\n}\n\nfunction looksLikeChecklist(tokens: Token[], index: number) {\n  return (\n    isInline(tokens[index]) &&\n    isListItem(tokens[index - 2]) &&\n    isParagraph(tokens[index - 1]) &&\n    matches(tokens[index])\n  );\n}\n\nexport default function markdownItCheckbox(md: MarkdownIt): void {\n  function render(tokens: Token[], idx: number) {\n    const token = tokens[idx];\n    const checked = !!token.attrGet(\"checked\");\n\n    if (token.nesting === 1) {\n      // opening tag\n      return `<li class=\"checkbox-list-item\"><span class=\"checkbox ${\n        checked ? \"checked\" : \"\"\n      }\">${checked ? \"[x]\" : \"[ ]\"}</span>`;\n    } else {\n      // closing tag\n      return \"</li>\\n\";\n    }\n  }\n\n  md.renderer.rules.checkbox_item_open = render;\n  md.renderer.rules.checkbox_item_close = render;\n\n  // insert a new rule after the \"inline\" rules are parsed\n  md.core.ruler.after(\"inline\", \"checkboxes\", (state) => {\n    const tokens = state.tokens;\n\n    // work backwards through the tokens and find text that looks like a checkbox\n    for (let i = tokens.length - 1; i > 0; i--) {\n      const matches = looksLikeChecklist(tokens, i);\n      if (matches) {\n        const value = matches[1];\n        const checked = value.toLowerCase() === \"x\";\n\n        // convert surrounding list tokens\n        if (tokens[i - 3].type === \"bullet_list_open\") {\n          tokens[i - 3].type = \"checkbox_list_open\";\n        }\n\n        if (tokens[i + 3].type === \"bullet_list_close\") {\n          tokens[i + 3].type = \"checkbox_list_close\";\n        }\n\n        // remove [ ] [x] from list item label – must use the content from the\n        // child for escaped characters to be unescaped correctly.\n        const tokenChildren = tokens[i].children;\n        if (tokenChildren) {\n          const contentMatches = tokenChildren[0].content.match(CHECKBOX_REGEX);\n\n          if (contentMatches) {\n            const label = contentMatches[2];\n\n            tokens[i].content = label;\n            tokenChildren[0].content = label;\n          }\n        }\n\n        // open list item and ensure checked state is transferred\n        tokens[i - 2].type = \"checkbox_item_open\";\n\n        if (checked === true) {\n          tokens[i - 2].attrs = [[\"checked\", \"true\"]];\n        }\n\n        // close the list item\n        let j = i;\n        while (tokens[j].type !== \"list_item_close\") {\n          j++;\n        }\n        tokens[j].type = \"checkbox_item_close\";\n      }\n    }\n\n    return false;\n  });\n}\n","import Token from \"markdown-it/lib/token\";\nimport { NodeSpec, Node as ProsemirrorNode, NodeType } from \"prosemirror-model\";\nimport {\n  splitListItem,\n  sinkListItem,\n  liftListItem,\n} from \"prosemirror-schema-list\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport checkboxRule from \"../rules/checkboxes\";\nimport Node from \"./Node\";\n\nexport default class CheckboxItem extends Node {\n  get name() {\n    return \"checkbox_item\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      attrs: {\n        checked: {\n          default: false,\n        },\n      },\n      content: \"paragraph block*\",\n      defining: true,\n      draggable: true,\n      parseDOM: [\n        {\n          tag: `li[data-type=\"${this.name}\"]`,\n          getAttrs: (dom: HTMLLIElement) => ({\n            checked: dom.className.includes(\"checked\"),\n          }),\n        },\n      ],\n      toDOM: (node) => {\n        const input = document.createElement(\"span\");\n        input.tabIndex = -1;\n        input.className = \"checkbox\";\n        input.setAttribute(\"aria-checked\", node.attrs.checked.toString());\n        input.setAttribute(\"role\", \"checkbox\");\n        input.addEventListener(\"click\", this.handleClick);\n\n        return [\n          \"li\",\n          {\n            \"data-type\": this.name,\n            class: node.attrs.checked ? \"checked\" : undefined,\n          },\n          [\n            \"span\",\n            {\n              contentEditable: \"false\",\n            },\n            input,\n          ],\n          [\"div\", 0],\n        ];\n      },\n    };\n  }\n\n  get rulePlugins() {\n    return [checkboxRule];\n  }\n\n  handleClick = (event: Event) => {\n    if (!(event.target instanceof HTMLSpanElement)) {\n      return;\n    }\n\n    const { view } = this.editor;\n    const { tr } = view.state;\n    const { top, left } = event.target.getBoundingClientRect();\n    const result = view.posAtCoords({ top, left });\n\n    if (result) {\n      const transaction = tr.setNodeMarkup(result.inside, undefined, {\n        checked: event.target.getAttribute(\"aria-checked\") !== \"true\",\n      });\n      view.dispatch(transaction);\n    }\n  };\n\n  keys({ type }: { type: NodeType }) {\n    return {\n      Enter: splitListItem(type),\n      Tab: sinkListItem(type),\n      \"Shift-Tab\": liftListItem(type),\n      \"Mod-]\": sinkListItem(type),\n      \"Mod-[\": liftListItem(type),\n    };\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    state.write(node.attrs.checked ? \"[x] \" : \"[ ] \");\n    state.renderContent(node);\n  }\n\n  parseMarkdown() {\n    return {\n      block: \"checkbox_item\",\n      getAttrs: (tok: Token) => ({\n        checked: tok.attrGet(\"checked\") ? true : undefined,\n      }),\n    };\n  }\n}\n","import { wrappingInputRule } from \"prosemirror-inputrules\";\nimport {\n  NodeSpec,\n  NodeType,\n  Schema,\n  Node as ProsemirrorNode,\n} from \"prosemirror-model\";\nimport toggleList from \"../commands/toggleList\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport Node from \"./Node\";\n\nexport default class CheckboxList extends Node {\n  get name() {\n    return \"checkbox_list\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      group: \"block\",\n      content: \"checkbox_item+\",\n      toDOM: () => [\"ul\", { class: this.name }, 0],\n      parseDOM: [\n        {\n          tag: `[class=\"${this.name}\"]`,\n        },\n      ],\n    };\n  }\n\n  keys({ type, schema }: { type: NodeType; schema: Schema }) {\n    return {\n      \"Shift-Ctrl-7\": toggleList(type, schema.nodes.checkbox_item),\n    };\n  }\n\n  commands({ type, schema }: { type: NodeType; schema: Schema }) {\n    return () => toggleList(type, schema.nodes.checkbox_item);\n  }\n\n  inputRules({ type }: { type: NodeType }) {\n    return [wrappingInputRule(/^-?\\s*(\\[ \\])\\s$/i, type)];\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    state.renderList(node, \"  \", () => \"- \");\n  }\n\n  parseMarkdown() {\n    return { block: \"checkbox_list\" };\n  }\n}\n","import { setBlockType } from \"prosemirror-commands\";\nimport { NodeType } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\nimport isNodeActive from \"../queries/isNodeActive\";\nimport { Dispatch } from \"../types\";\n\nexport default function toggleBlockType(\n  type: NodeType,\n  toggleType: NodeType,\n  attrs = {}\n) {\n  return (state: EditorState, dispatch?: Dispatch) => {\n    const isActive = isNodeActive(type, attrs)(state);\n\n    if (isActive) {\n      return setBlockType(toggleType)(state, dispatch);\n    }\n\n    return setBlockType(type, attrs)(state, dispatch);\n  };\n}\n","import { flattenDeep } from \"lodash\";\nimport { Node } from \"prosemirror-model\";\nimport { Plugin, PluginKey, Transaction } from \"prosemirror-state\";\nimport { findBlockNodes } from \"prosemirror-utils\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport refractor from \"refractor/core\";\n\nexport const LANGUAGES = {\n  none: \"None\", // additional entry to disable highlighting\n  bash: \"Bash\",\n  css: \"CSS\",\n  clike: \"C\",\n  csharp: \"C#\",\n  go: \"Go\",\n  markup: \"HTML\",\n  objectivec: \"Objective-C\",\n  java: \"Java\",\n  javascript: \"JavaScript\",\n  json: \"JSON\",\n  perl: \"Perl\",\n  php: \"PHP\",\n  powershell: \"Powershell\",\n  python: \"Python\",\n  ruby: \"Ruby\",\n  rust: \"Rust\",\n  sql: \"SQL\",\n  solidity: \"Solidity\",\n  typescript: \"TypeScript\",\n  yaml: \"YAML\",\n};\n\ntype ParsedNode = {\n  text: string;\n  classes: string[];\n};\n\nconst cache: Record<number, { node: Node; decorations: Decoration[] }> = {};\n\nfunction getDecorations({ doc, name }: { doc: Node; name: string }) {\n  const decorations: Decoration[] = [];\n  const blocks: { node: Node; pos: number }[] = findBlockNodes(doc).filter(\n    (item) => item.node.type.name === name\n  );\n\n  function parseNodes(\n    nodes: refractor.RefractorNode[],\n    classNames: string[] = []\n  ): any {\n    return nodes.map((node) => {\n      if (node.type === \"element\") {\n        const classes = [...classNames, ...(node.properties.className || [])];\n        return parseNodes(node.children, classes);\n      }\n\n      return {\n        text: node.value,\n        classes: classNames,\n      };\n    });\n  }\n\n  blocks.forEach((block) => {\n    let startPos = block.pos + 1;\n    const language = block.node.attrs.language;\n    if (!language || language === \"none\" || !refractor.registered(language)) {\n      return;\n    }\n\n    if (!cache[block.pos] || !cache[block.pos].node.eq(block.node)) {\n      const nodes = refractor.highlight(block.node.textContent, language);\n      const _decorations = flattenDeep(parseNodes(nodes))\n        .map((node: ParsedNode) => {\n          const from = startPos;\n          const to = from + node.text.length;\n\n          startPos = to;\n\n          return {\n            ...node,\n            from,\n            to,\n          };\n        })\n        .filter((node) => node.classes && node.classes.length)\n        .map((node) =>\n          Decoration.inline(node.from, node.to, {\n            class: node.classes.join(\" \"),\n          })\n        );\n\n      cache[block.pos] = {\n        node: block.node,\n        decorations: _decorations,\n      };\n    }\n    cache[block.pos].decorations.forEach((decoration) => {\n      decorations.push(decoration);\n    });\n  });\n\n  Object.keys(cache)\n    .filter((pos) => !blocks.find((block) => block.pos === Number(pos)))\n    .forEach((pos) => {\n      delete cache[Number(pos)];\n    });\n\n  return DecorationSet.create(doc, decorations);\n}\n\nexport default function Prism({ name }: { name: string }) {\n  let highlighted = false;\n\n  return new Plugin({\n    key: new PluginKey(\"prism\"),\n    state: {\n      init: (_: Plugin, { doc }) => {\n        return DecorationSet.create(doc, []);\n      },\n      apply: (transaction: Transaction, decorationSet, oldState, state) => {\n        const nodeName = state.selection.$head.parent.type.name;\n        const previousNodeName = oldState.selection.$head.parent.type.name;\n        const codeBlockChanged =\n          transaction.docChanged && [nodeName, previousNodeName].includes(name);\n        const ySyncEdit = !!transaction.getMeta(\"y-sync$\");\n\n        if (!highlighted || codeBlockChanged || ySyncEdit) {\n          highlighted = true;\n          return getDecorations({ doc: transaction.doc, name });\n        }\n\n        return decorationSet.map(transaction.mapping, transaction.doc);\n      },\n    },\n    view: (view) => {\n      if (!highlighted) {\n        // we don't highlight code blocks on the first render as part of mounting\n        // as it's expensive (relative to the rest of the document). Instead let\n        // it render un-highlighted and then trigger a defered render of Prism\n        // by updating the plugins metadata\n        setTimeout(() => {\n          view.dispatch(view.state.tr.setMeta(\"prism\", { loaded: true }));\n        }, 10);\n      }\n      return {};\n    },\n    props: {\n      decorations(state) {\n        return this.getState(state);\n      },\n    },\n  });\n}\n","import { EditorState } from \"prosemirror-state\";\nimport isMarkActive from \"./isMarkActive\";\n\nexport default function isInCode(state: EditorState): boolean {\n  if (state.schema.nodes.code_block) {\n    const $head = state.selection.$head;\n    for (let d = $head.depth; d > 0; d--) {\n      if ($head.node(d).type === state.schema.nodes.code_block) {\n        return true;\n      }\n    }\n  }\n\n  return isMarkActive(state.schema.marks.code_inline)(state);\n}\n","import copy from \"copy-to-clipboard\";\nimport Token from \"markdown-it/lib/token\";\nimport { textblockTypeInputRule } from \"prosemirror-inputrules\";\nimport {\n  NodeSpec,\n  NodeType,\n  Schema,\n  Node as ProsemirrorNode,\n} from \"prosemirror-model\";\nimport {\n  EditorState,\n  Selection,\n  TextSelection,\n  Transaction,\n} from \"prosemirror-state\";\nimport refractor from \"refractor/core\";\nimport bash from \"refractor/lang/bash\";\nimport clike from \"refractor/lang/clike\";\nimport csharp from \"refractor/lang/csharp\";\nimport css from \"refractor/lang/css\";\nimport go from \"refractor/lang/go\";\nimport java from \"refractor/lang/java\";\nimport javascript from \"refractor/lang/javascript\";\nimport json from \"refractor/lang/json\";\nimport markup from \"refractor/lang/markup\";\nimport objectivec from \"refractor/lang/objectivec\";\nimport perl from \"refractor/lang/perl\";\nimport php from \"refractor/lang/php\";\nimport powershell from \"refractor/lang/powershell\";\nimport python from \"refractor/lang/python\";\nimport ruby from \"refractor/lang/ruby\";\nimport rust from \"refractor/lang/rust\";\nimport solidity from \"refractor/lang/solidity\";\nimport sql from \"refractor/lang/sql\";\nimport typescript from \"refractor/lang/typescript\";\nimport yaml from \"refractor/lang/yaml\";\nimport { Dictionary } from \"~/hooks/useDictionary\";\n\nimport toggleBlockType from \"../commands/toggleBlockType\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport Prism, { LANGUAGES } from \"../plugins/Prism\";\nimport isInCode from \"../queries/isInCode\";\nimport { Dispatch } from \"../types\";\nimport Node from \"./Node\";\n\nconst PERSISTENCE_KEY = \"rme-code-language\";\nconst DEFAULT_LANGUAGE = \"javascript\";\n\n[\n  bash,\n  css,\n  clike,\n  csharp,\n  go,\n  java,\n  javascript,\n  json,\n  markup,\n  objectivec,\n  perl,\n  php,\n  python,\n  powershell,\n  ruby,\n  rust,\n  sql,\n  solidity,\n  typescript,\n  yaml,\n].forEach(refractor.register);\n\nexport default class CodeFence extends Node {\n  constructor(options: {\n    dictionary: Dictionary;\n    onShowToast: (message: string) => void;\n  }) {\n    super(options);\n  }\n\n  get languageOptions() {\n    return Object.entries(LANGUAGES);\n  }\n\n  get name() {\n    return \"code_fence\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      attrs: {\n        language: {\n          default: DEFAULT_LANGUAGE,\n        },\n      },\n      content: \"text*\",\n      marks: \"\",\n      group: \"block\",\n      code: true,\n      defining: true,\n      draggable: false,\n      parseDOM: [\n        { tag: \"code\" },\n        { tag: \"pre\", preserveWhitespace: \"full\" },\n        {\n          tag: \".code-block\",\n          preserveWhitespace: \"full\",\n          contentElement: \"code\",\n          getAttrs: (dom: HTMLDivElement) => {\n            return {\n              language: dom.dataset.language,\n            };\n          },\n        },\n      ],\n      toDOM: (node) => {\n        const button = document.createElement(\"button\");\n        button.innerText = \"Copy\";\n        button.type = \"button\";\n        button.addEventListener(\"click\", this.handleCopyToClipboard);\n\n        const select = document.createElement(\"select\");\n        select.addEventListener(\"change\", this.handleLanguageChange);\n\n        const actions = document.createElement(\"div\");\n        actions.className = \"code-actions\";\n        actions.appendChild(select);\n        actions.appendChild(button);\n\n        this.languageOptions.forEach(([key, label]) => {\n          const option = document.createElement(\"option\");\n          const value = key === \"none\" ? \"\" : key;\n          option.value = value;\n          option.innerText = label;\n          option.selected = node.attrs.language === value;\n          select.appendChild(option);\n        });\n\n        return [\n          \"div\",\n          { class: \"code-block\", \"data-language\": node.attrs.language },\n          [\"div\", { contentEditable: \"false\" }, actions],\n          [\"pre\", [\"code\", { spellCheck: \"false\" }, 0]],\n        ];\n      },\n    };\n  }\n\n  commands({ type, schema }: { type: NodeType; schema: Schema }) {\n    return (attrs: Record<string, any>) =>\n      toggleBlockType(type, schema.nodes.paragraph, {\n        language: localStorage?.getItem(PERSISTENCE_KEY) || DEFAULT_LANGUAGE,\n        ...attrs,\n      });\n  }\n\n  keys({ type, schema }: { type: NodeType; schema: Schema }) {\n    return {\n      \"Shift-Ctrl-\\\\\": toggleBlockType(type, schema.nodes.paragraph),\n      \"Shift-Enter\": (state: EditorState, dispatch: Dispatch) => {\n        if (!isInCode(state)) {\n          return false;\n        }\n        const {\n          tr,\n          selection,\n        }: { tr: Transaction; selection: TextSelection } = state;\n        const text = selection?.$anchor?.nodeBefore?.text;\n\n        let newText = \"\\n\";\n\n        if (text) {\n          const splitByNewLine = text.split(\"\\n\");\n          const numOfSpaces = splitByNewLine[splitByNewLine.length - 1].search(\n            /\\S|$/\n          );\n          newText += \" \".repeat(numOfSpaces);\n        }\n\n        dispatch(tr.insertText(newText, selection.from, selection.to));\n        return true;\n      },\n      Tab: (state: EditorState, dispatch: Dispatch) => {\n        if (!isInCode(state)) {\n          return false;\n        }\n\n        const { tr, selection } = state;\n        dispatch(tr.insertText(\"  \", selection.from, selection.to));\n        return true;\n      },\n    };\n  }\n\n  handleCopyToClipboard = (event: MouseEvent) => {\n    const { view } = this.editor;\n    const element = event.target;\n    if (!(element instanceof HTMLButtonElement)) {\n      return;\n    }\n    const { top, left } = element.getBoundingClientRect();\n    const result = view.posAtCoords({ top, left });\n\n    if (result) {\n      const node = view.state.doc.nodeAt(result.pos);\n      if (node) {\n        copy(node.textContent);\n        this.options.onShowToast(this.options.dictionary.codeCopied);\n      }\n    }\n  };\n\n  handleLanguageChange = (event: InputEvent) => {\n    const { view } = this.editor;\n    const { tr } = view.state;\n    const element = event.currentTarget;\n    if (!(element instanceof HTMLSelectElement)) {\n      return;\n    }\n\n    const { top, left } = element.getBoundingClientRect();\n    const result = view.posAtCoords({ top, left });\n\n    if (result) {\n      const language = element.value;\n\n      const transaction = tr\n        .setSelection(Selection.near(view.state.doc.resolve(result.inside)))\n        .setNodeMarkup(result.inside, undefined, {\n          language,\n        });\n      view.dispatch(transaction);\n\n      localStorage?.setItem(PERSISTENCE_KEY, language);\n    }\n  };\n\n  get plugins() {\n    return [Prism({ name: this.name })];\n  }\n\n  inputRules({ type }: { type: NodeType }) {\n    return [textblockTypeInputRule(/^```$/, type)];\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    state.write(\"```\" + (node.attrs.language || \"\") + \"\\n\");\n    state.text(node.textContent, false);\n    state.ensureNewLine();\n    state.write(\"```\");\n    state.closeBlock(node);\n  }\n\n  get markdownToken() {\n    return \"fence\";\n  }\n\n  parseMarkdown() {\n    return {\n      block: \"code_block\",\n      getAttrs: (tok: Token) => ({ language: tok.info }),\n    };\n  }\n}\n","import CodeFence from \"./CodeFence\";\n\nexport default class CodeBlock extends CodeFence {\n  get name() {\n    return \"code_block\";\n  }\n\n  get markdownToken() {\n    return \"code_block\";\n  }\n}\n","import { OpenIcon } from \"outline-icons\";\nimport * as React from \"react\";\nimport { DefaultTheme, ThemeProps } from \"styled-components\";\nimport { EmbedProps as Props } from \"../embeds\";\nimport Widget from \"./Widget\";\n\nexport default function DisabledEmbed(props: Props & ThemeProps<DefaultTheme>) {\n  return (\n    <Widget\n      title={props.embed.title}\n      href={props.attrs.href}\n      icon={props.embed.icon(undefined)}\n      context={props.attrs.href.replace(/^https?:\\/\\//, \"\")}\n      isSelected={props.isSelected}\n      theme={props.theme}\n    >\n      <OpenIcon color=\"currentColor\" size={20} />\n    </Widget>\n  );\n}\n","import MarkdownIt from \"markdown-it\";\nimport Token from \"markdown-it/lib/token\";\nimport { EmbedDescriptor } from \"../types\";\n\nfunction isParagraph(token: Token) {\n  return token.type === \"paragraph_open\";\n}\n\nfunction isInline(token: Token) {\n  return token.type === \"inline\" && token.level === 1;\n}\n\nfunction isLinkOpen(token: Token) {\n  return token.type === \"link_open\";\n}\n\nfunction isLinkClose(token: Token) {\n  return token.type === \"link_close\";\n}\n\nexport default function linksToEmbeds(embeds: EmbedDescriptor[]) {\n  function isEmbed(token: Token, link: Token) {\n    const href = link.attrs ? link.attrs[0][1] : \"\";\n    const simpleLink = href === token.content;\n\n    if (!simpleLink) {\n      return false;\n    }\n    if (!embeds) {\n      return false;\n    }\n\n    for (const embed of embeds) {\n      const matches = embed.matcher(href);\n      if (matches) {\n        return {\n          ...embed,\n          matches,\n        };\n      }\n    }\n\n    return false;\n  }\n\n  return function markdownEmbeds(md: MarkdownIt) {\n    md.core.ruler.after(\"inline\", \"embeds\", (state) => {\n      const tokens = state.tokens;\n      let insideLink;\n\n      for (let i = 0; i < tokens.length - 1; i++) {\n        // once we find an inline token look through it's children for links\n        if (isInline(tokens[i]) && isParagraph(tokens[i - 1])) {\n          const tokenChildren = tokens[i].children || [];\n\n          for (let j = 0; j < tokenChildren.length - 1; j++) {\n            const current = tokenChildren[j];\n            if (!current) {\n              continue;\n            }\n\n            if (isLinkOpen(current)) {\n              insideLink = current;\n              continue;\n            }\n\n            if (isLinkClose(current)) {\n              insideLink = null;\n              continue;\n            }\n\n            // of hey, we found a link – lets check to see if it should be\n            // converted to an embed\n            if (insideLink) {\n              const result = isEmbed(current, insideLink);\n              if (result) {\n                const { content } = current;\n\n                // convert to embed token\n                const token = new Token(\"embed\", \"iframe\", 0);\n                token.attrSet(\"href\", content);\n\n                // delete the inline link – this makes the assumption that the\n                // embed is the only thing in the para.\n                tokens.splice(i - 1, 3, token);\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      return false;\n    });\n  };\n}\n","import Token from \"markdown-it/lib/token\";\nimport { NodeSpec, NodeType, Node as ProsemirrorNode } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\nimport * as React from \"react\";\nimport DisabledEmbed from \"../components/DisabledEmbed\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport embedsRule from \"../rules/embeds\";\nimport { ComponentProps, Dispatch } from \"../types\";\nimport Node from \"./Node\";\n\nconst cache = {};\n\nexport default class Embed extends Node {\n  get name() {\n    return \"embed\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      content: \"inline*\",\n      group: \"block\",\n      atom: true,\n      attrs: {\n        href: {},\n      },\n      parseDOM: [\n        {\n          tag: \"iframe.embed\",\n          getAttrs: (dom: HTMLIFrameElement) => {\n            const { embeds } = this.editor.props;\n            const href = dom.getAttribute(\"src\") || \"\";\n\n            if (embeds) {\n              for (const embed of embeds) {\n                const matches = embed.matcher(href);\n                if (matches) {\n                  return {\n                    href,\n                  };\n                }\n              }\n            }\n\n            return {};\n          },\n        },\n      ],\n      toDOM: (node) => [\n        \"iframe\",\n        { class: \"embed\", src: node.attrs.href, contentEditable: \"false\" },\n        0,\n      ],\n      toPlainText: (node) => node.attrs.href,\n    };\n  }\n\n  get rulePlugins() {\n    return [embedsRule(this.options.embeds)];\n  }\n\n  component({ isEditable, isSelected, theme, node }: ComponentProps) {\n    const { embeds, embedsDisabled } = this.editor.props;\n\n    // matches are cached in module state to avoid re running loops and regex\n    // here. Unfortunately this function is not compatible with React.memo or\n    // we would use that instead.\n    const hit = cache[node.attrs.href];\n    let Component = hit ? hit.Component : undefined;\n    let matches = hit ? hit.matches : undefined;\n    let embed = hit ? hit.embed : undefined;\n\n    if (!Component) {\n      for (const e of embeds) {\n        const m = e.matcher(node.attrs.href);\n        if (m) {\n          Component = e.component;\n          matches = m;\n          embed = e;\n          cache[node.attrs.href] = { Component, embed, matches };\n        }\n      }\n    }\n\n    if (!Component) {\n      return null;\n    }\n\n    if (embedsDisabled) {\n      return (\n        <DisabledEmbed\n          attrs={{ href: node.attrs.href, matches }}\n          embed={embed}\n          isEditable={isEditable}\n          isSelected={isSelected}\n          theme={theme}\n        />\n      );\n    }\n\n    return (\n      <Component\n        attrs={{ ...node.attrs, matches }}\n        isEditable={isEditable}\n        isSelected={isSelected}\n        theme={theme}\n      />\n    );\n  }\n\n  commands({ type }: { type: NodeType }) {\n    return (attrs: Record<string, any>) => (\n      state: EditorState,\n      dispatch: Dispatch\n    ) => {\n      dispatch(\n        state.tr.replaceSelectionWith(type.create(attrs)).scrollIntoView()\n      );\n      return true;\n    };\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    state.ensureNewLine();\n    state.write(\n      \"[\" +\n        state.esc(node.attrs.href, false) +\n        \"](\" +\n        state.esc(node.attrs.href, false) +\n        \")\"\n    );\n    state.write(\"\\n\\n\");\n  }\n\n  parseMarkdown() {\n    return {\n      node: \"embed\",\n      getAttrs: (token: Token) => ({\n        href: token.attrGet(\"href\"),\n      }),\n    };\n  }\n}\n","import { NodeType } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\nimport { Dispatch } from \"../types\";\n\nexport default function backspaceToParagraph(type: NodeType) {\n  return (state: EditorState, dispatch: Dispatch) => {\n    const { $from, from, to, empty } = state.selection;\n\n    // if the selection has anything in it then use standard delete behavior\n    if (!empty) {\n      return null;\n    }\n\n    // check we're in a matching node\n    if ($from.parent.type !== type) {\n      return null;\n    }\n\n    // check if we're at the beginning of the heading\n    const $pos = state.doc.resolve(from - 1);\n    if ($pos.parent === $from.parent) {\n      return null;\n    }\n\n    // okay, replace it with a paragraph\n    dispatch(\n      state.tr\n        .setBlockType(from, to, type.schema.nodes.paragraph)\n        .scrollIntoView()\n    );\n    return true;\n  };\n}\n","import { Node } from \"prosemirror-model\";\nimport { findBlockNodes, NodeWithPos } from \"prosemirror-utils\";\n\nexport default function findCollapsedNodes(doc: Node): NodeWithPos[] {\n  const blocks = findBlockNodes(doc);\n  const nodes: NodeWithPos[] = [];\n\n  let withinCollapsedHeading;\n\n  for (const block of blocks) {\n    if (block.node.type.name === \"heading\") {\n      if (\n        !withinCollapsedHeading ||\n        block.node.attrs.level <= withinCollapsedHeading\n      ) {\n        if (block.node.attrs.collapsed) {\n          if (!withinCollapsedHeading) {\n            withinCollapsedHeading = block.node.attrs.level;\n          }\n        } else {\n          withinCollapsedHeading = undefined;\n        }\n        continue;\n      }\n    }\n\n    if (withinCollapsedHeading) {\n      nodes.push(block);\n    }\n  }\n\n  return nodes;\n}\n","import { NodeType } from \"prosemirror-model\";\nimport { EditorState, TextSelection } from \"prosemirror-state\";\nimport { findBlockNodes } from \"prosemirror-utils\";\nimport findCollapsedNodes from \"../queries/findCollapsedNodes\";\nimport { Dispatch } from \"../types\";\n\nexport default function splitHeading(type: NodeType) {\n  return (state: EditorState, dispatch: Dispatch): boolean => {\n    const { $from, from, $to, to } = state.selection;\n\n    // check we're in a matching heading node\n    if ($from.parent.type !== type) {\n      return false;\n    }\n\n    // check that the caret is at the end of the content, if it isn't then\n    // standard node splitting behaviour applies\n    const endPos = $to.after() - 1;\n    if (endPos !== to) {\n      return false;\n    }\n\n    // If the node isn't collapsed standard behavior applies\n    if (!$from.parent.attrs.collapsed) {\n      return false;\n    }\n\n    // Find the next visible block after this one. It takes into account nested\n    // collapsed headings and reaching the end of the document\n    const allBlocks = findBlockNodes(state.doc);\n    const collapsedBlocks = findCollapsedNodes(state.doc);\n    const visibleBlocks = allBlocks.filter(\n      (a) => !collapsedBlocks.find((b) => b.pos === a.pos)\n    );\n    const nextVisibleBlock = visibleBlocks.find((a) => a.pos > from);\n    const pos = nextVisibleBlock\n      ? nextVisibleBlock.pos\n      : state.doc.content.size;\n\n    // Insert our new heading directly before the next visible block\n    const transaction = state.tr.insert(\n      pos,\n      type.create({ ...$from.parent.attrs, collapsed: false })\n    );\n\n    // Move the selection into the new heading node and make sure it's on screen\n    dispatch(\n      transaction\n        .setSelection(\n          TextSelection.near(\n            transaction.doc.resolve(\n              Math.min(pos + 1, transaction.doc.content.size)\n            )\n          )\n        )\n        .scrollIntoView()\n    );\n\n    return true;\n  };\n}\n","import copy from \"copy-to-clipboard\";\nimport { textblockTypeInputRule } from \"prosemirror-inputrules\";\nimport {\n  Node as ProsemirrorNode,\n  NodeSpec,\n  NodeType,\n  Schema,\n} from \"prosemirror-model\";\nimport { Plugin, Selection } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport backspaceToParagraph from \"../commands/backspaceToParagraph\";\nimport splitHeading from \"../commands/splitHeading\";\nimport toggleBlockType from \"../commands/toggleBlockType\";\nimport { Command } from \"../lib/Extension\";\nimport headingToSlug, { headingToPersistenceKey } from \"../lib/headingToSlug\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport Node from \"./Node\";\n\nexport default class Heading extends Node {\n  className = \"heading-name\";\n\n  get name() {\n    return \"heading\";\n  }\n\n  get defaultOptions() {\n    return {\n      levels: [1, 2, 3, 4],\n      collapsed: undefined,\n    };\n  }\n\n  get schema(): NodeSpec {\n    return {\n      attrs: {\n        level: {\n          default: 1,\n        },\n        collapsed: {\n          default: undefined,\n        },\n      },\n      content: \"inline*\",\n      group: \"block\",\n      defining: true,\n      draggable: false,\n      parseDOM: this.options.levels.map((level: number) => ({\n        tag: `h${level}`,\n        attrs: { level },\n        contentElement: \".heading-content\",\n      })),\n      toDOM: (node) => {\n        const anchor = document.createElement(\"button\");\n        anchor.innerText = \"#\";\n        anchor.type = \"button\";\n        anchor.className = \"heading-anchor\";\n        anchor.addEventListener(\"click\", (event) => this.handleCopyLink(event));\n\n        const fold = document.createElement(\"button\");\n        fold.innerText = \"\";\n        fold.innerHTML =\n          '<svg fill=\"currentColor\" width=\"12\" height=\"24\" viewBox=\"6 0 12 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M8.23823905,10.6097108 L11.207376,14.4695888 L11.207376,14.4695888 C11.54411,14.907343 12.1719566,14.989236 12.6097108,14.652502 C12.6783439,14.5997073 12.7398293,14.538222 12.792624,14.4695888 L15.761761,10.6097108 L15.761761,10.6097108 C16.0984949,10.1719566 16.0166019,9.54410997 15.5788477,9.20737601 C15.4040391,9.07290785 15.1896811,9 14.969137,9 L9.03086304,9 L9.03086304,9 C8.47857829,9 8.03086304,9.44771525 8.03086304,10 C8.03086304,10.2205442 8.10377089,10.4349022 8.23823905,10.6097108 Z\" /></svg>';\n        fold.type = \"button\";\n        fold.className = `heading-fold ${\n          node.attrs.collapsed ? \"collapsed\" : \"\"\n        }`;\n        fold.addEventListener(\"mousedown\", (event) =>\n          this.handleFoldContent(event)\n        );\n\n        return [\n          `h${node.attrs.level + (this.options.offset || 0)}`,\n          [\n            \"span\",\n            {\n              contentEditable: \"false\",\n              class: `heading-actions ${\n                node.attrs.collapsed ? \"collapsed\" : \"\"\n              }`,\n            },\n            anchor,\n            fold,\n          ],\n          [\n            \"span\",\n            {\n              class: \"heading-content\",\n            },\n            0,\n          ],\n        ];\n      },\n    };\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    state.write(state.repeat(\"#\", node.attrs.level) + \" \");\n    state.renderInline(node);\n    state.closeBlock(node);\n  }\n\n  parseMarkdown() {\n    return {\n      block: \"heading\",\n      getAttrs: (token: Record<string, any>) => ({\n        level: +token.tag.slice(1),\n      }),\n    };\n  }\n\n  commands({ type, schema }: { type: NodeType; schema: Schema }) {\n    return (attrs: Record<string, any>) => {\n      return toggleBlockType(type, schema.nodes.paragraph, attrs);\n    };\n  }\n\n  handleFoldContent = (event: MouseEvent) => {\n    event.preventDefault();\n    if (!(event.currentTarget instanceof HTMLButtonElement)) {\n      return;\n    }\n\n    const { view } = this.editor;\n    const hadFocus = view.hasFocus();\n    const { tr } = view.state;\n    const { top, left } = event.currentTarget.getBoundingClientRect();\n    const result = view.posAtCoords({ top, left });\n\n    if (result) {\n      const node = view.state.doc.nodeAt(result.inside);\n\n      if (node) {\n        const endOfHeadingPos = result.inside + node.nodeSize;\n        const $pos = view.state.doc.resolve(endOfHeadingPos);\n        const collapsed = !node.attrs.collapsed;\n\n        if (collapsed && view.state.selection.to > endOfHeadingPos) {\n          // move selection to the end of the collapsed heading\n          tr.setSelection(Selection.near($pos, -1));\n        }\n\n        const transaction = tr.setNodeMarkup(result.inside, undefined, {\n          ...node.attrs,\n          collapsed,\n        });\n\n        const persistKey = headingToPersistenceKey(node, this.editor.props.id);\n\n        if (collapsed) {\n          localStorage?.setItem(persistKey, \"collapsed\");\n        } else {\n          localStorage?.removeItem(persistKey);\n        }\n\n        view.dispatch(transaction);\n\n        if (hadFocus) {\n          view.focus();\n        }\n      }\n    }\n  };\n\n  handleCopyLink = (event: MouseEvent) => {\n    // this is unfortunate but appears to be the best way to grab the anchor\n    // as it's added directly to the dom by a decoration.\n    const anchor =\n      event.currentTarget instanceof HTMLButtonElement &&\n      (event.currentTarget.parentNode?.parentNode\n        ?.previousSibling as HTMLElement);\n\n    if (!anchor || !anchor.className.includes(this.className)) {\n      throw new Error(\"Did not find anchor as previous sibling of heading\");\n    }\n    const hash = `#${anchor.id}`;\n\n    // the existing url might contain a hash already, lets make sure to remove\n    // that rather than appending another one.\n    const urlWithoutHash = window.location.href.split(\"#\")[0];\n    copy(urlWithoutHash + hash);\n\n    this.options.onShowToast(this.options.dictionary.linkCopied);\n  };\n\n  keys({ type, schema }: { type: NodeType; schema: Schema }) {\n    const options = this.options.levels.reduce(\n      (items: Record<string, Command>, level: number) => ({\n        ...items,\n        ...{\n          [`Shift-Ctrl-${level}`]: toggleBlockType(\n            type,\n            schema.nodes.paragraph,\n            { level }\n          ),\n        },\n      }),\n      {}\n    );\n\n    return {\n      ...options,\n      Backspace: backspaceToParagraph(type),\n      Enter: splitHeading(type),\n    };\n  }\n\n  get plugins() {\n    const getAnchors = (doc: ProsemirrorNode) => {\n      const decorations: Decoration[] = [];\n      const previouslySeen = {};\n\n      doc.descendants((node, pos) => {\n        if (node.type.name !== this.name) {\n          return;\n        }\n\n        // calculate the optimal id\n        const slug = headingToSlug(node);\n        let id = slug;\n\n        // check if we've already used it, and if so how many times?\n        // Make the new id based on that number ensuring that we have\n        // unique ID's even when headings are identical\n        if (previouslySeen[slug] > 0) {\n          id = headingToSlug(node, previouslySeen[slug]);\n        }\n\n        // record that we've seen this slug for the next loop\n        previouslySeen[slug] =\n          previouslySeen[slug] !== undefined ? previouslySeen[slug] + 1 : 1;\n\n        decorations.push(\n          Decoration.widget(\n            pos,\n            () => {\n              const anchor = document.createElement(\"a\");\n              anchor.id = id;\n              anchor.className = this.className;\n              return anchor;\n            },\n            {\n              side: -1,\n              key: id,\n            }\n          )\n        );\n      });\n\n      return DecorationSet.create(doc, decorations);\n    };\n\n    const plugin: Plugin = new Plugin({\n      state: {\n        init: (config, state) => {\n          return getAnchors(state.doc);\n        },\n        apply: (tr, oldState) => {\n          return tr.docChanged ? getAnchors(tr.doc) : oldState;\n        },\n      },\n      props: {\n        decorations: (state) => plugin.getState(state),\n      },\n    });\n\n    return [plugin];\n  }\n\n  inputRules({ type }: { type: NodeType }) {\n    return this.options.levels.map((level: number) =>\n      textblockTypeInputRule(new RegExp(`^(#{1,${level}})\\\\s$`), type, () => ({\n        level,\n      }))\n    );\n  }\n}\n","import Token from \"markdown-it/lib/token\";\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { NodeSpec, NodeType, Node as ProsemirrorNode } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport { Dispatch } from \"../types\";\nimport Node from \"./Node\";\n\nexport default class HorizontalRule extends Node {\n  get name() {\n    return \"hr\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      attrs: {\n        markup: {\n          default: \"---\",\n        },\n      },\n      group: \"block\",\n      parseDOM: [{ tag: \"hr\" }],\n      toDOM: (node) => {\n        return [\n          \"hr\",\n          { class: node.attrs.markup === \"***\" ? \"page-break\" : \"\" },\n        ];\n      },\n    };\n  }\n\n  commands({ type }: { type: NodeType }) {\n    return (attrs: Record<string, any>) => (\n      state: EditorState,\n      dispatch: Dispatch\n    ) => {\n      dispatch(\n        state.tr.replaceSelectionWith(type.create(attrs)).scrollIntoView()\n      );\n      return true;\n    };\n  }\n\n  keys({ type }: { type: NodeType }) {\n    return {\n      \"Mod-_\": (state: EditorState, dispatch: Dispatch) => {\n        dispatch(state.tr.replaceSelectionWith(type.create()).scrollIntoView());\n        return true;\n      },\n    };\n  }\n\n  inputRules({ type }: { type: NodeType }) {\n    return [\n      new InputRule(/^(?:---|___\\s|\\*\\*\\*\\s)$/, (state, match, start, end) => {\n        const { tr } = state;\n\n        if (match[0]) {\n          const markup = match[0].trim();\n          tr.replaceWith(start - 1, end, type.create({ markup }));\n        }\n\n        return tr;\n      }),\n    ];\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    state.write(`\\n${node.attrs.markup}`);\n    state.closeBlock(node);\n  }\n\n  parseMarkdown() {\n    return {\n      node: \"hr\",\n      getAttrs: (tok: Token) => ({\n        markup: tok.markup,\n      }),\n    };\n  }\n}\n","import { Node } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\n\nexport default function getParentListItem(\n  state: EditorState\n): [Node, number] | void {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--) {\n    const node = $head.node(d);\n    if ([\"list_item\", \"checkbox_item\"].includes(node.type.name)) {\n      return [node, $head.before(d)];\n    }\n  }\n}\n","import { NodeSpec, NodeType, Node as ProsemirrorNode } from \"prosemirror-model\";\nimport {\n  splitListItem,\n  sinkListItem,\n  liftListItem,\n} from \"prosemirror-schema-list\";\nimport {\n  Transaction,\n  EditorState,\n  Plugin,\n  TextSelection,\n} from \"prosemirror-state\";\nimport { findParentNodeClosestToPos } from \"prosemirror-utils\";\nimport { DecorationSet, Decoration } from \"prosemirror-view\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport getParentListItem from \"../queries/getParentListItem\";\nimport isInList from \"../queries/isInList\";\nimport isList from \"../queries/isList\";\nimport { Dispatch } from \"../types\";\nimport Node from \"./Node\";\n\nexport default class ListItem extends Node {\n  get name() {\n    return \"list_item\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      content: \"paragraph block*\",\n      defining: true,\n      draggable: true,\n      parseDOM: [{ tag: \"li\" }],\n      toDOM: () => [\"li\", 0],\n    };\n  }\n\n  get plugins() {\n    return [\n      new Plugin({\n        state: {\n          init() {\n            return DecorationSet.empty;\n          },\n          apply: (\n            tr: Transaction,\n            set: DecorationSet,\n            oldState: EditorState,\n            newState: EditorState\n          ) => {\n            const action = tr.getMeta(\"li\");\n            if (!action && !tr.docChanged) {\n              return set;\n            }\n\n            // Adjust decoration positions to changes made by the transaction\n            set = set.map(tr.mapping, tr.doc);\n\n            switch (action?.event) {\n              case \"mouseover\": {\n                const result = findParentNodeClosestToPos(\n                  newState.doc.resolve(action.pos),\n                  (node) =>\n                    node.type.name === this.name ||\n                    node.type.name === \"checkbox_item\"\n                );\n\n                if (!result) {\n                  return set;\n                }\n\n                const list = findParentNodeClosestToPos(\n                  newState.doc.resolve(action.pos),\n                  (node) => isList(node, this.editor.schema)\n                );\n\n                if (!list) {\n                  return set;\n                }\n\n                const start = list.node.attrs.order || 1;\n\n                let listItemNumber = 0;\n                list.node.content.forEach((li, _, index) => {\n                  if (li === result.node) {\n                    listItemNumber = index;\n                  }\n                });\n\n                const counterLength = String(start + listItemNumber).length;\n\n                return set.add(tr.doc, [\n                  Decoration.node(\n                    result.pos,\n                    result.pos + result.node.nodeSize,\n                    {\n                      class: `hovering`,\n                    },\n                    {\n                      hover: true,\n                    }\n                  ),\n                  Decoration.node(\n                    result.pos,\n                    result.pos + result.node.nodeSize,\n                    {\n                      class: `counter-${counterLength}`,\n                    }\n                  ),\n                ]);\n              }\n              case \"mouseout\": {\n                const result = findParentNodeClosestToPos(\n                  newState.doc.resolve(action.pos),\n                  (node) =>\n                    node.type.name === this.name ||\n                    node.type.name === \"checkbox_item\"\n                );\n\n                if (!result) {\n                  return set;\n                }\n\n                return set.remove(\n                  set.find(\n                    result.pos,\n                    result.pos + result.node.nodeSize,\n                    (spec) => spec.hover\n                  )\n                );\n              }\n              default:\n            }\n\n            return set;\n          },\n        },\n        props: {\n          decorations(state) {\n            return this.getState(state);\n          },\n          handleDOMEvents: {\n            mouseover: (view, event) => {\n              const { state, dispatch } = view;\n              const target = event.target as HTMLElement;\n              const li = target?.closest(\"li\");\n\n              if (!li) {\n                return false;\n              }\n              if (!view.dom.contains(li)) {\n                return false;\n              }\n              const pos = view.posAtDOM(li, 0);\n              if (!pos) {\n                return false;\n              }\n\n              dispatch(\n                state.tr.setMeta(\"li\", {\n                  event: \"mouseover\",\n                  pos,\n                })\n              );\n              return false;\n            },\n            mouseout: (view, event) => {\n              const { state, dispatch } = view;\n              const target = event.target as HTMLElement;\n              const li = target?.closest(\"li\");\n\n              if (!li) {\n                return false;\n              }\n              if (!view.dom.contains(li)) {\n                return false;\n              }\n              const pos = view.posAtDOM(li, 0);\n              if (!pos) {\n                return false;\n              }\n\n              dispatch(\n                state.tr.setMeta(\"li\", {\n                  event: \"mouseout\",\n                  pos,\n                })\n              );\n              return false;\n            },\n          },\n        },\n      }),\n    ];\n  }\n\n  keys({ type }: { type: NodeType }) {\n    return {\n      Enter: splitListItem(type),\n      Tab: sinkListItem(type),\n      \"Shift-Tab\": liftListItem(type),\n      \"Mod-]\": sinkListItem(type),\n      \"Mod-[\": liftListItem(type),\n      \"Shift-Enter\": (state: EditorState, dispatch: Dispatch) => {\n        if (!isInList(state)) {\n          return false;\n        }\n        if (!state.selection.empty) {\n          return false;\n        }\n\n        const { tr, selection } = state;\n        dispatch(tr.split(selection.to));\n        return true;\n      },\n      \"Alt-ArrowUp\": (state: EditorState, dispatch: Dispatch) => {\n        if (!state.selection.empty) {\n          return false;\n        }\n        const result = getParentListItem(state);\n        if (!result) {\n          return false;\n        }\n\n        const [li, pos] = result;\n        const $pos = state.doc.resolve(pos);\n\n        if (\n          !$pos.nodeBefore ||\n          ![\"list_item\", \"checkbox_item\"].includes($pos.nodeBefore.type.name)\n        ) {\n          console.log(\"Node before not a list item\");\n          return false;\n        }\n\n        const { tr } = state;\n        const newPos = pos - $pos.nodeBefore.nodeSize;\n\n        dispatch(\n          tr\n            .delete(pos, pos + li.nodeSize)\n            .insert(newPos, li)\n            .setSelection(TextSelection.near(tr.doc.resolve(newPos)))\n        );\n        return true;\n      },\n      \"Alt-ArrowDown\": (state: EditorState, dispatch: Dispatch) => {\n        if (!state.selection.empty) {\n          return false;\n        }\n        const result = getParentListItem(state);\n        if (!result) {\n          return false;\n        }\n\n        const [li, pos] = result;\n        const $pos = state.doc.resolve(pos + li.nodeSize);\n\n        if (\n          !$pos.nodeAfter ||\n          ![\"list_item\", \"checkbox_item\"].includes($pos.nodeAfter.type.name)\n        ) {\n          console.log(\"Node after not a list item\");\n          return false;\n        }\n\n        const { tr } = state;\n        const newPos = pos + li.nodeSize + $pos.nodeAfter.nodeSize;\n\n        dispatch(\n          tr\n            .insert(newPos, li)\n            .setSelection(TextSelection.near(tr.doc.resolve(newPos)))\n            .delete(pos, pos + li.nodeSize)\n        );\n        return true;\n      },\n    };\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    state.renderContent(node);\n  }\n\n  parseMarkdown() {\n    return { block: \"list_item\" };\n  }\n}\n","import MarkdownIt from \"markdown-it\";\nimport customFence from \"markdown-it-container\";\nimport Token from \"markdown-it/lib/token\";\n\nexport default function notice(md: MarkdownIt): void {\n  return customFence(md, \"notice\", {\n    marker: \":\",\n    validate: () => true,\n    render: function (tokens: Token[], idx: number) {\n      const { info } = tokens[idx];\n\n      if (tokens[idx].nesting === 1) {\n        // opening tag\n        return `<div class=\"notice notice-${md.utils.escapeHtml(info)}\">\\n`;\n      } else {\n        // closing tag\n        return \"</div>\\n\";\n      }\n    },\n  });\n}\n","import Token from \"markdown-it/lib/token\";\nimport { WarningIcon, InfoIcon, StarredIcon } from \"outline-icons\";\nimport { wrappingInputRule } from \"prosemirror-inputrules\";\nimport { NodeSpec, Node as ProsemirrorNode, NodeType } from \"prosemirror-model\";\nimport * as React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport toggleWrap from \"../commands/toggleWrap\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport noticesRule from \"../rules/notices\";\nimport Node from \"./Node\";\n\nexport default class Notice extends Node {\n  get styleOptions() {\n    return Object.entries({\n      info: this.options.dictionary.info,\n      warning: this.options.dictionary.warning,\n      tip: this.options.dictionary.tip,\n    });\n  }\n\n  get name() {\n    return \"container_notice\";\n  }\n\n  get rulePlugins() {\n    return [noticesRule];\n  }\n\n  get schema(): NodeSpec {\n    return {\n      attrs: {\n        style: {\n          default: \"info\",\n        },\n      },\n      content: \"block+\",\n      group: \"block\",\n      defining: true,\n      draggable: true,\n      parseDOM: [\n        {\n          tag: \"div.notice-block\",\n          preserveWhitespace: \"full\",\n          contentElement: \"div.content\",\n          getAttrs: (dom: HTMLDivElement) => ({\n            style: dom.className.includes(\"tip\")\n              ? \"tip\"\n              : dom.className.includes(\"warning\")\n              ? \"warning\"\n              : undefined,\n          }),\n        },\n      ],\n      toDOM: (node) => {\n        const select = document.createElement(\"select\");\n        select.addEventListener(\"change\", this.handleStyleChange);\n\n        this.styleOptions.forEach(([key, label]) => {\n          const option = document.createElement(\"option\");\n          option.value = key;\n          option.innerText = label;\n          option.selected = node.attrs.style === key;\n          select.appendChild(option);\n        });\n\n        const actions = document.createElement(\"div\");\n        actions.className = \"notice-actions\";\n        actions.appendChild(select);\n\n        let component;\n\n        if (node.attrs.style === \"tip\") {\n          component = <StarredIcon color=\"currentColor\" />;\n        } else if (node.attrs.style === \"warning\") {\n          component = <WarningIcon color=\"currentColor\" />;\n        } else {\n          component = <InfoIcon color=\"currentColor\" />;\n        }\n\n        const icon = document.createElement(\"div\");\n        icon.className = \"icon\";\n        ReactDOM.render(component, icon);\n\n        return [\n          \"div\",\n          { class: `notice-block ${node.attrs.style}` },\n          icon,\n          [\"div\", { contentEditable: \"false\" }, actions],\n          [\"div\", { class: \"content\" }, 0],\n        ];\n      },\n    };\n  }\n\n  commands({ type }: { type: NodeType }) {\n    return (attrs: Record<string, any>) => toggleWrap(type, attrs);\n  }\n\n  handleStyleChange = (event: InputEvent) => {\n    const { view } = this.editor;\n    const { tr } = view.state;\n    const element = event.target;\n    if (!(element instanceof HTMLSelectElement)) {\n      return;\n    }\n\n    const { top, left } = element.getBoundingClientRect();\n    const result = view.posAtCoords({ top, left });\n\n    if (result) {\n      const transaction = tr.setNodeMarkup(result.inside, undefined, {\n        style: element.value,\n      });\n      view.dispatch(transaction);\n    }\n  };\n\n  inputRules({ type }: { type: NodeType }) {\n    return [wrappingInputRule(/^:::$/, type)];\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    state.write(\"\\n:::\" + (node.attrs.style || \"info\") + \"\\n\");\n    state.renderContent(node);\n    state.ensureNewLine();\n    state.write(\":::\");\n    state.closeBlock(node);\n  }\n\n  parseMarkdown() {\n    return {\n      block: \"container_notice\",\n      getAttrs: (tok: Token) => ({ style: tok.info }),\n    };\n  }\n}\n","import Token from \"markdown-it/lib/token\";\nimport { wrappingInputRule } from \"prosemirror-inputrules\";\nimport {\n  NodeSpec,\n  NodeType,\n  Schema,\n  Node as ProsemirrorNode,\n} from \"prosemirror-model\";\nimport toggleList from \"../commands/toggleList\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport Node from \"./Node\";\n\nexport default class OrderedList extends Node {\n  get name() {\n    return \"ordered_list\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      attrs: {\n        order: {\n          default: 1,\n        },\n      },\n      content: \"list_item+\",\n      group: \"block\",\n      parseDOM: [\n        {\n          tag: \"ol\",\n          getAttrs: (dom: HTMLOListElement) => ({\n            order: dom.hasAttribute(\"start\")\n              ? parseInt(dom.getAttribute(\"start\") || \"1\", 10)\n              : 1,\n          }),\n        },\n      ],\n      toDOM: (node) =>\n        node.attrs.order === 1\n          ? [\"ol\", 0]\n          : [\"ol\", { start: node.attrs.order }, 0],\n    };\n  }\n\n  commands({ type, schema }: { type: NodeType; schema: Schema }) {\n    return () => toggleList(type, schema.nodes.list_item);\n  }\n\n  keys({ type, schema }: { type: NodeType; schema: Schema }) {\n    return {\n      \"Shift-Ctrl-9\": toggleList(type, schema.nodes.list_item),\n    };\n  }\n\n  inputRules({ type }: { type: NodeType }) {\n    return [\n      wrappingInputRule(\n        /^(\\d+)\\.\\s$/,\n        type,\n        (match) => ({ order: +match[1] }),\n        (match, node) => node.childCount + node.attrs.order === +match[1]\n      ),\n    ];\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    state.write(\"\\n\");\n\n    const start = node.attrs.order !== undefined ? node.attrs.order : 1;\n    const maxW = `${start + node.childCount - 1}`.length;\n    const space = state.repeat(\" \", maxW + 2);\n\n    state.renderList(node, space, (index: number) => {\n      const nStr = `${start + index}`;\n      return state.repeat(\" \", maxW - nStr.length) + nStr + \". \";\n    });\n  }\n\n  parseMarkdown() {\n    return {\n      block: \"ordered_list\",\n      getAttrs: (tok: Token) => ({\n        order: parseInt(tok.attrGet(\"start\") || \"1\", 10),\n      }),\n    };\n  }\n}\n","import MarkdownIt from \"markdown-it\";\nimport Token from \"markdown-it/lib/token\";\n\nconst BREAK_REGEX = /(?:^|[^\\\\])\\\\n/;\n\nexport default function markdownTables(md: MarkdownIt): void {\n  // insert a new rule after the \"inline\" rules are parsed\n  md.core.ruler.after(\"inline\", \"tables-pm\", (state) => {\n    const tokens = state.tokens;\n    let inside = false;\n\n    for (let i = tokens.length - 1; i > 0; i--) {\n      if (inside) {\n        tokens[i].level--;\n      }\n\n      // convert unescaped \\n in the text into real br tag\n      if (tokens[i].type === \"inline\" && tokens[i].content.match(BREAK_REGEX)) {\n        const existing = tokens[i].children || [];\n        tokens[i].children = [];\n\n        existing.forEach((child) => {\n          const breakParts = child.content.split(BREAK_REGEX);\n\n          // a schema agnostic way to know if a node is inline code would be\n          // great, for now we are stuck checking the node type.\n          if (breakParts.length > 1 && child.type !== \"code_inline\") {\n            breakParts.forEach((part, index) => {\n              const token = new Token(\"text\", \"\", 1);\n              token.content = part.trim();\n              tokens[i].children?.push(token);\n\n              if (index < breakParts.length - 1) {\n                const brToken = new Token(\"br\", \"br\", 1);\n                tokens[i].children?.push(brToken);\n              }\n            });\n          } else {\n            tokens[i].children?.push(child);\n          }\n        });\n      }\n\n      // filter out incompatible tokens from markdown-it that we don't need\n      // in prosemirror. thead/tbody do nothing.\n      if (\n        [\"thead_open\", \"thead_close\", \"tbody_open\", \"tbody_close\"].includes(\n          tokens[i].type\n        )\n      ) {\n        inside = !inside;\n        tokens.splice(i, 1);\n      }\n\n      if ([\"th_open\", \"td_open\"].includes(tokens[i].type)) {\n        // markdown-it table parser does not return paragraphs inside the cells\n        // but prosemirror requires them, so we add 'em in here.\n        tokens.splice(i + 1, 0, new Token(\"paragraph_open\", \"p\", 1));\n\n        // markdown-it table parser stores alignment as html styles, convert\n        // to a simple string here\n        const tokenAttrs = tokens[i].attrs;\n        if (tokenAttrs) {\n          const style = tokenAttrs[0][1];\n          tokens[i].info = style.split(\":\")[1];\n        }\n      }\n\n      if ([\"th_close\", \"td_close\"].includes(tokens[i].type)) {\n        tokens.splice(i, 0, new Token(\"paragraph_close\", \"p\", -1));\n      }\n    }\n\n    return false;\n  });\n}\n","import { NodeSpec, Node as ProsemirrorNode, Schema } from \"prosemirror-model\";\nimport { EditorState, Plugin, TextSelection } from \"prosemirror-state\";\nimport {\n  addColumnAfter,\n  addColumnBefore,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  goToNextCell,\n  isInTable,\n  tableEditing,\n  toggleHeaderCell,\n  toggleHeaderColumn,\n  toggleHeaderRow,\n} from \"prosemirror-tables\";\nimport {\n  addRowAt,\n  createTable,\n  getCellsInColumn,\n  moveRow,\n} from \"prosemirror-utils\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport tablesRule from \"../rules/tables\";\nimport { Dispatch } from \"../types\";\nimport Node from \"./Node\";\n\nexport default class Table extends Node {\n  get name() {\n    return \"table\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      content: \"tr+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: \"block\",\n      parseDOM: [{ tag: \"table\" }],\n      toDOM() {\n        return [\n          \"div\",\n          { class: \"scrollable-wrapper\" },\n          [\n            \"div\",\n            { class: \"scrollable\" },\n            [\"table\", { class: \"rme-table\" }, [\"tbody\", 0]],\n          ],\n        ];\n      },\n    };\n  }\n\n  get rulePlugins() {\n    return [tablesRule];\n  }\n\n  commands({ schema }: { schema: Schema }) {\n    return {\n      createTable: ({\n        rowsCount,\n        colsCount,\n      }: {\n        rowsCount: number;\n        colsCount: number;\n      }) => (state: EditorState, dispatch: Dispatch) => {\n        const offset = state.tr.selection.anchor + 1;\n        const nodes = createTable(schema, rowsCount, colsCount);\n        const tr = state.tr.replaceSelectionWith(nodes).scrollIntoView();\n        const resolvedPos = tr.doc.resolve(offset);\n\n        tr.setSelection(TextSelection.near(resolvedPos));\n        dispatch(tr);\n        return true;\n      },\n      setColumnAttr: ({\n        index,\n        alignment,\n      }: {\n        index: number;\n        alignment: string;\n      }) => (state: EditorState, dispatch: Dispatch) => {\n        const cells = getCellsInColumn(index)(state.selection) || [];\n        let transaction = state.tr;\n        cells.forEach(({ pos }) => {\n          transaction = transaction.setNodeMarkup(pos, undefined, {\n            alignment,\n          });\n        });\n        dispatch(transaction);\n        return true;\n      },\n      addColumnBefore: () => addColumnBefore,\n      addColumnAfter: () => addColumnAfter,\n      deleteColumn: () => deleteColumn,\n      addRowAfter: ({ index }: { index: number }) => (\n        state: EditorState,\n        dispatch: Dispatch\n      ) => {\n        if (index === 0) {\n          // A little hack to avoid cloning the heading row by cloning the row\n          // beneath and then moving it to the right index.\n          const tr = addRowAt(index + 2, true)(state.tr);\n          dispatch(moveRow(index + 2, index + 1)(tr));\n        } else {\n          dispatch(addRowAt(index + 1, true)(state.tr));\n        }\n        return true;\n      },\n      deleteRow: () => deleteRow,\n      deleteTable: () => deleteTable,\n      toggleHeaderColumn: () => toggleHeaderColumn,\n      toggleHeaderRow: () => toggleHeaderRow,\n      toggleHeaderCell: () => toggleHeaderCell,\n    };\n  }\n\n  keys() {\n    return {\n      Tab: goToNextCell(1),\n      \"Shift-Tab\": goToNextCell(-1),\n      Enter: (state: EditorState, dispatch: Dispatch) => {\n        if (!isInTable(state)) {\n          return false;\n        }\n\n        // TODO: Adding row at the end for now, can we find the current cell\n        // row index and add the row below that?\n        const cells = getCellsInColumn(0)(state.selection) || [];\n\n        dispatch(addRowAt(cells.length, true)(state.tr));\n        return true;\n      },\n    };\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    state.renderTable(node);\n    state.closeBlock(node);\n  }\n\n  parseMarkdown() {\n    return { block: \"table\" };\n  }\n\n  get plugins() {\n    return [\n      tableEditing(),\n      new Plugin({\n        props: {\n          decorations: (state) => {\n            const { doc } = state;\n            const decorations: Decoration[] = [];\n            let index = 0;\n\n            doc.descendants((node, pos) => {\n              if (node.type.name !== this.name) {\n                return;\n              }\n\n              const elements = document.getElementsByClassName(\"rme-table\");\n              const table = elements[index];\n              if (!table) {\n                return;\n              }\n\n              const element = table.parentElement;\n              const shadowRight = !!(\n                element && element.scrollWidth > element.clientWidth\n              );\n\n              if (shadowRight) {\n                decorations.push(\n                  Decoration.widget(\n                    pos + 1,\n                    () => {\n                      const shadow = document.createElement(\"div\");\n                      shadow.className = \"scrollable-shadow right\";\n                      return shadow;\n                    },\n                    {\n                      key: \"table-shadow-right\",\n                    }\n                  )\n                );\n              }\n              index++;\n            });\n\n            return DecorationSet.create(doc, decorations);\n          },\n        },\n      }),\n    ];\n  }\n}\n","import Token from \"markdown-it/lib/token\";\nimport { NodeSpec } from \"prosemirror-model\";\nimport { Plugin } from \"prosemirror-state\";\nimport {\n  isTableSelected,\n  isRowSelected,\n  getCellsInColumn,\n  selectRow,\n  selectTable,\n} from \"prosemirror-utils\";\nimport { DecorationSet, Decoration } from \"prosemirror-view\";\nimport Node from \"./Node\";\n\nexport default class TableCell extends Node {\n  get name() {\n    return \"td\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      content: \"paragraph+\",\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [{ tag: \"td\" }],\n      toDOM(node) {\n        return [\n          \"td\",\n          node.attrs.alignment\n            ? { style: `text-align: ${node.attrs.alignment}` }\n            : {},\n          0,\n        ];\n      },\n      attrs: {\n        colspan: { default: 1 },\n        rowspan: { default: 1 },\n        alignment: { default: null },\n      },\n    };\n  }\n\n  toMarkdown() {\n    // see: renderTable\n  }\n\n  parseMarkdown() {\n    return {\n      block: \"td\",\n      getAttrs: (tok: Token) => ({ alignment: tok.info }),\n    };\n  }\n\n  get plugins() {\n    return [\n      new Plugin({\n        props: {\n          decorations: (state) => {\n            const { doc, selection } = state;\n            const decorations: Decoration[] = [];\n            const cells = getCellsInColumn(0)(selection);\n\n            if (cells) {\n              cells.forEach(({ pos }, index) => {\n                if (index === 0) {\n                  decorations.push(\n                    Decoration.widget(pos + 1, () => {\n                      let className = \"grip-table\";\n                      const selected = isTableSelected(selection);\n                      if (selected) {\n                        className += \" selected\";\n                      }\n                      const grip = document.createElement(\"a\");\n                      grip.className = className;\n                      grip.addEventListener(\"mousedown\", (event) => {\n                        event.preventDefault();\n                        event.stopImmediatePropagation();\n                        this.editor.view.dispatch(selectTable(state.tr));\n                      });\n                      return grip;\n                    })\n                  );\n                }\n                decorations.push(\n                  Decoration.widget(pos + 1, () => {\n                    const rowSelected = isRowSelected(index)(selection);\n\n                    let className = \"grip-row\";\n                    if (rowSelected) {\n                      className += \" selected\";\n                    }\n                    if (index === 0) {\n                      className += \" first\";\n                    }\n                    if (index === cells.length - 1) {\n                      className += \" last\";\n                    }\n                    const grip = document.createElement(\"a\");\n                    grip.className = className;\n                    grip.addEventListener(\"mousedown\", (event) => {\n                      event.preventDefault();\n                      event.stopImmediatePropagation();\n                      this.editor.view.dispatch(selectRow(index)(state.tr));\n                    });\n                    return grip;\n                  })\n                );\n              });\n            }\n\n            return DecorationSet.create(doc, decorations);\n          },\n        },\n      }),\n    ];\n  }\n}\n","import Token from \"markdown-it/lib/token\";\nimport { NodeSpec } from \"prosemirror-model\";\nimport { Plugin } from \"prosemirror-state\";\nimport {\n  isColumnSelected,\n  getCellsInRow,\n  selectColumn,\n} from \"prosemirror-utils\";\nimport { DecorationSet, Decoration } from \"prosemirror-view\";\nimport Node from \"./Node\";\n\nexport default class TableHeadCell extends Node {\n  get name() {\n    return \"th\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      content: \"paragraph+\",\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [{ tag: \"th\" }],\n      toDOM(node) {\n        return [\n          \"th\",\n          node.attrs.alignment\n            ? { style: `text-align: ${node.attrs.alignment}` }\n            : {},\n          0,\n        ];\n      },\n      attrs: {\n        colspan: { default: 1 },\n        rowspan: { default: 1 },\n        alignment: { default: null },\n      },\n    };\n  }\n\n  toMarkdown() {\n    // see: renderTable\n  }\n\n  parseMarkdown() {\n    return {\n      block: \"th\",\n      getAttrs: (tok: Token) => ({ alignment: tok.info }),\n    };\n  }\n\n  get plugins() {\n    return [\n      new Plugin({\n        props: {\n          decorations: (state) => {\n            const { doc, selection } = state;\n            const decorations: Decoration[] = [];\n            const cells = getCellsInRow(0)(selection);\n\n            if (cells) {\n              cells.forEach(({ pos }, index) => {\n                decorations.push(\n                  Decoration.widget(pos + 1, () => {\n                    const colSelected = isColumnSelected(index)(selection);\n                    let className = \"grip-column\";\n                    if (colSelected) {\n                      className += \" selected\";\n                    }\n                    if (index === 0) {\n                      className += \" first\";\n                    } else if (index === cells.length - 1) {\n                      className += \" last\";\n                    }\n                    const grip = document.createElement(\"a\");\n                    grip.className = className;\n                    grip.addEventListener(\"mousedown\", (event) => {\n                      event.preventDefault();\n                      event.stopImmediatePropagation();\n                      this.editor.view.dispatch(selectColumn(index)(state.tr));\n                    });\n                    return grip;\n                  })\n                );\n              });\n            }\n\n            return DecorationSet.create(doc, decorations);\n          },\n        },\n      }),\n    ];\n  }\n}\n","import { NodeSpec } from \"prosemirror-model\";\nimport Node from \"./Node\";\n\nexport default class TableRow extends Node {\n  get name() {\n    return \"tr\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      content: \"(th | td)*\",\n      tableRole: \"row\",\n      parseDOM: [{ tag: \"tr\" }],\n      toDOM() {\n        return [\"tr\", 0];\n      },\n    };\n  }\n\n  parseMarkdown() {\n    return { block: \"tr\" };\n  }\n}\n","import { PlusIcon } from \"outline-icons\";\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { EditorState, Plugin } from \"prosemirror-state\";\nimport { isInTable } from \"prosemirror-tables\";\nimport { findParentNode } from \"prosemirror-utils\";\nimport { Decoration, DecorationSet, EditorView } from \"prosemirror-view\";\nimport * as React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Extension from \"../lib/Extension\";\nimport { EventType } from \"../types\";\n\nconst MAX_MATCH = 500;\nconst OPEN_REGEX = /^\\/(\\w+)?$/;\nconst CLOSE_REGEX = /(^(?!\\/(\\w+)?)(.*)$|^\\/(([\\w\\W]+)\\s.*|\\s)$|^\\/((\\W)+)$)/;\n\n// based on the input rules code in Prosemirror, here:\n// https://github.com/ProseMirror/prosemirror-inputrules/blob/master/src/inputrules.js\nexport function run(\n  view: EditorView,\n  from: number,\n  to: number,\n  regex: RegExp,\n  handler: (\n    state: EditorState,\n    match: RegExpExecArray | null,\n    from?: number,\n    to?: number\n  ) => boolean | null\n) {\n  if (view.composing) {\n    return false;\n  }\n  const state = view.state;\n  const $from = state.doc.resolve(from);\n  if ($from.parent.type.spec.code) {\n    return false;\n  }\n\n  const textBefore = $from.parent.textBetween(\n    Math.max(0, $from.parentOffset - MAX_MATCH),\n    $from.parentOffset,\n    undefined,\n    \"\\ufffc\"\n  );\n\n  const match = regex.exec(textBefore);\n  const tr = handler(state, match, match ? from - match[0].length : from, to);\n  if (!tr) {\n    return false;\n  }\n  return true;\n}\n\nexport default class BlockMenuTrigger extends Extension {\n  get name() {\n    return \"blockmenu\";\n  }\n\n  get plugins() {\n    const button = document.createElement(\"button\");\n    button.className = \"block-menu-trigger\";\n    button.type = \"button\";\n    ReactDOM.render(<PlusIcon color=\"currentColor\" />, button);\n\n    return [\n      new Plugin({\n        props: {\n          handleClick: () => {\n            this.editor.events.emit(EventType.blockMenuClose);\n            return false;\n          },\n          handleKeyDown: (view, event) => {\n            // Prosemirror input rules are not triggered on backspace, however\n            // we need them to be evaluted for the filter trigger to work\n            // correctly. This additional handler adds inputrules-like handling.\n            if (event.key === \"Backspace\") {\n              // timeout ensures that the delete has been handled by prosemirror\n              // and any characters removed, before we evaluate the rule.\n              setTimeout(() => {\n                const { pos } = view.state.selection.$from;\n                return run(view, pos, pos, OPEN_REGEX, (state, match) => {\n                  if (match) {\n                    this.editor.events.emit(EventType.blockMenuOpen, match[1]);\n                  } else {\n                    this.editor.events.emit(EventType.blockMenuClose);\n                  }\n                  return null;\n                });\n              });\n            }\n\n            // If the query is active and we're navigating the block menu then\n            // just ignore the key events in the editor itself until we're done\n            if (\n              event.key === \"Enter\" ||\n              event.key === \"ArrowUp\" ||\n              event.key === \"ArrowDown\" ||\n              event.key === \"Tab\"\n            ) {\n              const { pos } = view.state.selection.$from;\n\n              return run(view, pos, pos, OPEN_REGEX, (state, match) => {\n                // just tell Prosemirror we handled it and not to do anything\n                return match ? true : null;\n              });\n            }\n\n            return false;\n          },\n          decorations: (state) => {\n            const parent = findParentNode(\n              (node) => node.type.name === \"paragraph\"\n            )(state.selection);\n\n            if (!parent) {\n              return;\n            }\n\n            const isTopLevel = state.selection.$from.depth === 1;\n            if (!isTopLevel) {\n              return;\n            }\n\n            const decorations: Decoration[] = [];\n            const isEmptyNode = parent && parent.node.content.size === 0;\n            const isSlash = parent && parent.node.textContent === \"/\";\n\n            if (isEmptyNode) {\n              decorations.push(\n                Decoration.widget(\n                  parent.pos,\n                  () => {\n                    button.addEventListener(\"click\", () => {\n                      this.editor.events.emit(EventType.blockMenuOpen, \"\");\n                    });\n                    return button;\n                  },\n                  {\n                    key: \"block-trigger\",\n                  }\n                )\n              );\n\n              const isEmptyDoc = state.doc.textContent === \"\";\n              if (!isEmptyDoc) {\n                decorations.push(\n                  Decoration.node(\n                    parent.pos,\n                    parent.pos + parent.node.nodeSize,\n                    {\n                      class: \"placeholder\",\n                      \"data-empty-text\": this.options.dictionary.newLineEmpty,\n                    }\n                  )\n                );\n              }\n            } else if (isSlash) {\n              decorations.push(\n                Decoration.node(parent.pos, parent.pos + parent.node.nodeSize, {\n                  class: \"placeholder\",\n                  \"data-empty-text\": `  ${this.options.dictionary.newLineWithSlash}`,\n                })\n              );\n            }\n\n            return DecorationSet.create(state.doc, decorations);\n          },\n        },\n      }),\n    ];\n  }\n\n  inputRules() {\n    return [\n      // main regex should match only:\n      // /word\n      new InputRule(OPEN_REGEX, (state, match) => {\n        if (\n          match &&\n          state.selection.$from.parent.type.name === \"paragraph\" &&\n          !isInTable(state)\n        ) {\n          this.editor.events.emit(EventType.blockMenuOpen, match[1]);\n        }\n        return null;\n      }),\n      // invert regex should match some of these scenarios:\n      // /<space>word\n      // /<space>\n      // /word<space>\n      new InputRule(CLOSE_REGEX, (state, match) => {\n        if (match) {\n          this.editor.events.emit(EventType.blockMenuClose);\n        }\n        return null;\n      }),\n    ];\n  }\n}\n","import { Plugin } from \"prosemirror-state\";\nimport { findBlockNodes } from \"prosemirror-utils\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport Extension from \"../lib/Extension\";\nimport { headingToPersistenceKey } from \"../lib/headingToSlug\";\nimport findCollapsedNodes from \"../queries/findCollapsedNodes\";\n\nexport default class Folding extends Extension {\n  get name() {\n    return \"folding\";\n  }\n\n  get plugins() {\n    let loaded = false;\n\n    return [\n      new Plugin({\n        view: (view) => {\n          loaded = false;\n          view.dispatch(view.state.tr.setMeta(\"folding\", { loaded: true }));\n          return {};\n        },\n        appendTransaction: (transactions, oldState, newState) => {\n          if (loaded) {\n            return;\n          }\n          if (\n            !transactions.some((transaction) => transaction.getMeta(\"folding\"))\n          ) {\n            return;\n          }\n\n          let modified = false;\n          const tr = newState.tr;\n          const blocks = findBlockNodes(newState.doc);\n\n          for (const block of blocks) {\n            if (block.node.type.name === \"heading\") {\n              const persistKey = headingToPersistenceKey(\n                block.node,\n                this.editor.props.id\n              );\n              const persistedState = localStorage?.getItem(persistKey);\n\n              if (persistedState === \"collapsed\") {\n                tr.setNodeMarkup(block.pos, undefined, {\n                  ...block.node.attrs,\n                  collapsed: true,\n                });\n                modified = true;\n              }\n            }\n          }\n\n          loaded = true;\n          return modified ? tr : null;\n        },\n        props: {\n          decorations: (state) => {\n            const { doc } = state;\n            const decorations: Decoration[] = findCollapsedNodes(doc).map(\n              (block) =>\n                Decoration.node(block.pos, block.pos + block.node.nodeSize, {\n                  class: \"folded-content\",\n                })\n            );\n\n            return DecorationSet.create(doc, decorations);\n          },\n        },\n      }),\n    ];\n  }\n}\n","import { GapCursor } from \"prosemirror-gapcursor\";\nimport {\n  Plugin,\n  Selection,\n  AllSelection,\n  TextSelection,\n  EditorState,\n} from \"prosemirror-state\";\nimport Extension, { Command } from \"../lib/Extension\";\nimport isInCode from \"../queries/isInCode\";\n\nexport default class Keys extends Extension {\n  get name() {\n    return \"keys\";\n  }\n\n  keys(): Record<string, Command> {\n    const onCancel = () => {\n      if (this.editor.props.onCancel) {\n        this.editor.props.onCancel();\n        return true;\n      }\n      return false;\n    };\n\n    return {\n      // No-ops prevent Tab escaping the editor bounds\n      Tab: () => true,\n      \"Shift-Tab\": () => true,\n\n      // Shortcuts for when editor has separate edit mode\n      \"Mod-Escape\": onCancel,\n      \"Shift-Escape\": onCancel,\n      \"Mod-s\": () => {\n        if (this.editor.props.onSave) {\n          this.editor.props.onSave({ done: false });\n          return true;\n        }\n        return false;\n      },\n      \"Mod-Enter\": (state: EditorState) => {\n        if (!isInCode(state) && this.editor.props.onSave) {\n          this.editor.props.onSave({ done: true });\n          return true;\n        }\n        return false;\n      },\n    };\n  }\n\n  get plugins() {\n    return [\n      new Plugin({\n        props: {\n          // we can't use the keys bindings for this as we want to preventDefault\n          // on the original keyboard event when handled\n          handleKeyDown: (view, event) => {\n            if (view.state.selection instanceof AllSelection) {\n              if (event.key === \"ArrowUp\") {\n                const selection = Selection.atStart(view.state.doc);\n                view.dispatch(view.state.tr.setSelection(selection));\n                return true;\n              }\n              if (event.key === \"ArrowDown\") {\n                const selection = Selection.atEnd(view.state.doc);\n                view.dispatch(view.state.tr.setSelection(selection));\n                return true;\n              }\n            }\n\n            // edge case where horizontal gap cursor does nothing if Enter key\n            // is pressed. Insert a newline and then move the cursor into it.\n            if (view.state.selection instanceof GapCursor) {\n              if (event.key === \"Enter\") {\n                view.dispatch(\n                  view.state.tr.insert(\n                    view.state.selection.from,\n                    view.state.schema.nodes.paragraph.create({})\n                  )\n                );\n                view.dispatch(\n                  view.state.tr.setSelection(\n                    TextSelection.near(\n                      view.state.doc.resolve(view.state.selection.from),\n                      -1\n                    )\n                  )\n                );\n                return true;\n              }\n            }\n\n            return false;\n          },\n        },\n      }),\n    ];\n  }\n}\n","import { toggleMark } from \"prosemirror-commands\";\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { MarkSpec, MarkType } from \"prosemirror-model\";\nimport markInputRule from \"../lib/markInputRule\";\nimport Mark from \"./Mark\";\n\nconst heavyWeightRegex = /^(bold(er)?|[5-9]\\d{2,})$/;\nconst normalWeightRegex = /^(normal|[1-4]\\d{2,})$/;\n\nexport default class Bold extends Mark {\n  get name() {\n    return \"strong\";\n  }\n\n  get schema(): MarkSpec {\n    return {\n      parseDOM: [\n        {\n          tag: \"b\",\n          // Google Docs includes <b> tags with font-weight: normal so we need\n          // to account for this case specifically as not becoming bold when pasted.\n          getAttrs: (dom: HTMLElement) =>\n            normalWeightRegex.test(dom.style.fontWeight) ? false : null,\n        },\n        { tag: \"strong\" },\n        {\n          style: \"font-weight\",\n          getAttrs: (style: string) => heavyWeightRegex.test(style) && null,\n        },\n      ],\n      toDOM: () => [\"strong\"],\n    };\n  }\n\n  inputRules({ type }: { type: MarkType }): InputRule[] {\n    return [markInputRule(/(?:\\*\\*)([^*]+)(?:\\*\\*)$/, type)];\n  }\n\n  keys({ type }: { type: MarkType }) {\n    return {\n      \"Mod-b\": toggleMark(type),\n      \"Mod-B\": toggleMark(type),\n    };\n  }\n\n  toMarkdown() {\n    return {\n      open: \"**\",\n      close: \"**\",\n      mixable: true,\n      expelEnclosingWhitespace: true,\n    };\n  }\n\n  parseMarkdown() {\n    return { mark: \"strong\" };\n  }\n}\n","/*\nCopyright 2020 Atlassian Pty Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n */\n\n// This file is based on the implementation found here:\n// https://bitbucket.org/atlassian/design-system-mirror/src/master/editor/editor-core/src/plugins/text-formatting/commands/text-formatting.ts\n\nimport { Selection, EditorState, TextSelection } from \"prosemirror-state\";\nimport isMarkActive from \"../queries/isMarkActive\";\nimport { Dispatch } from \"../types\";\n\nfunction hasCode(state: EditorState, pos: number) {\n  const { code_inline } = state.schema.marks;\n  const node = pos >= 0 && state.doc.nodeAt(pos);\n\n  return node\n    ? !!node.marks.filter((mark) => mark.type === code_inline).length\n    : false;\n}\n\nexport default function moveLeft() {\n  return (state: EditorState, dispatch: Dispatch): boolean => {\n    const { code_inline } = state.schema.marks;\n    const { empty, $cursor } = state.selection as TextSelection;\n    if (!empty || !$cursor) {\n      return false;\n    }\n\n    const { storedMarks } = state.tr;\n\n    if (code_inline) {\n      const insideCode = code_inline && isMarkActive(code_inline)(state);\n      const currentPosHasCode = hasCode(state, $cursor.pos);\n      const nextPosHasCode = hasCode(state, $cursor.pos - 1);\n      const nextNextPosHasCode = hasCode(state, $cursor.pos - 2);\n\n      const exitingCode =\n        currentPosHasCode && !nextPosHasCode && Array.isArray(storedMarks);\n      const atLeftEdge =\n        nextPosHasCode &&\n        !nextNextPosHasCode &&\n        (storedMarks === null ||\n          (Array.isArray(storedMarks) && !!storedMarks.length));\n      const atRightEdge =\n        ((exitingCode && Array.isArray(storedMarks) && !storedMarks.length) ||\n          (!exitingCode && storedMarks === null)) &&\n        !nextPosHasCode &&\n        nextNextPosHasCode;\n      const enteringCode =\n        !currentPosHasCode &&\n        nextPosHasCode &&\n        Array.isArray(storedMarks) &&\n        !storedMarks.length;\n\n      // at the right edge: remove code mark and move the cursor to the left\n      if (!insideCode && atRightEdge) {\n        const tr = state.tr.setSelection(\n          Selection.near(state.doc.resolve($cursor.pos - 1))\n        );\n\n        dispatch(tr.removeStoredMark(code_inline));\n\n        return true;\n      }\n\n      // entering code mark (from right edge): don't move the cursor, just add the mark\n      if (!insideCode && enteringCode) {\n        dispatch(state.tr.addStoredMark(code_inline.create()));\n        return true;\n      }\n\n      // at the left edge: add code mark and move the cursor to the left\n      if (insideCode && atLeftEdge) {\n        const tr = state.tr.setSelection(\n          Selection.near(state.doc.resolve($cursor.pos - 1))\n        );\n\n        dispatch(tr.addStoredMark(code_inline.create()));\n        return true;\n      }\n\n      // exiting code mark (or at the beginning of the line): don't move the cursor, just remove the mark\n      const isFirstChild = $cursor.index($cursor.depth - 1) === 0;\n      if (\n        insideCode &&\n        (exitingCode || (!$cursor.nodeBefore && isFirstChild))\n      ) {\n        dispatch(state.tr.removeStoredMark(code_inline));\n        return true;\n      }\n    }\n\n    return false;\n  };\n}\n","import { toggleMark } from \"prosemirror-commands\";\nimport {\n  MarkSpec,\n  MarkType,\n  Node as ProsemirrorNode,\n  Mark as ProsemirrorMark,\n} from \"prosemirror-model\";\nimport { Plugin } from \"prosemirror-state\";\nimport moveLeft from \"../commands/moveLeft\";\nimport moveRight from \"../commands/moveRight\";\nimport markInputRule from \"../lib/markInputRule\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport Mark from \"./Mark\";\n\nfunction backticksFor(node: ProsemirrorNode, side: -1 | 1) {\n  const ticks = /`+/g;\n  let match: RegExpMatchArray | null;\n  let len = 0;\n\n  if (node.isText) {\n    while ((match = ticks.exec(node.text || \"\"))) {\n      len = Math.max(len, match[0].length);\n    }\n  }\n\n  let result = len > 0 && side > 0 ? \" `\" : \"`\";\n  for (let i = 0; i < len; i++) {\n    result += \"`\";\n  }\n  if (len > 0 && side < 0) {\n    result += \" \";\n  }\n  return result;\n}\n\nexport default class Code extends Mark {\n  get name() {\n    return \"code_inline\";\n  }\n\n  get schema(): MarkSpec {\n    return {\n      excludes: \"_\",\n      parseDOM: [{ tag: \"code.inline\", preserveWhitespace: true }],\n      toDOM: () => [\"code\", { class: \"inline\", spellCheck: \"false\" }],\n    };\n  }\n\n  inputRules({ type }: { type: MarkType }) {\n    return [markInputRule(/(?:^|[^`])(`([^`]+)`)$/, type)];\n  }\n\n  keys({ type }: { type: MarkType }) {\n    // Note: This key binding only works on non-Mac platforms\n    // https://github.com/ProseMirror/prosemirror/issues/515\n    return {\n      \"Mod`\": toggleMark(type),\n      ArrowLeft: moveLeft(),\n      ArrowRight: moveRight(),\n    };\n  }\n\n  get plugins() {\n    return [\n      new Plugin({\n        props: {\n          // Typing a character inside of two backticks will wrap the character\n          // in an inline code mark.\n          handleTextInput: (view, from: number, to: number, text: string) => {\n            const { state } = view;\n\n            // Prevent access out of document bounds\n            if (from === 0 || to === state.doc.nodeSize - 1 || text === \"`\") {\n              return false;\n            }\n\n            if (\n              from === to &&\n              state.doc.textBetween(from - 1, from) === \"`\" &&\n              state.doc.textBetween(to, to + 1) === \"`\"\n            ) {\n              const start = from - 1;\n              const end = to + 1;\n              view.dispatch(\n                state.tr\n                  .delete(start, end)\n                  .insertText(text, start)\n                  .addMark(\n                    start,\n                    start + text.length,\n                    state.schema.marks.code_inline.create()\n                  )\n              );\n              return true;\n            }\n\n            return false;\n          },\n\n          // Pasting a character inside of two backticks will wrap the character\n          // in an inline code mark.\n          handlePaste: (view, _event, slice) => {\n            const { state } = view;\n            const { from, to } = state.selection;\n\n            // Prevent access out of document bounds\n            if (from === 0 || to === state.doc.nodeSize - 1) {\n              return false;\n            }\n\n            const start = from - 1;\n            const end = to + 1;\n            if (\n              from === to &&\n              state.doc.textBetween(start, from) === \"`\" &&\n              state.doc.textBetween(to, end) === \"`\"\n            ) {\n              view.dispatch(\n                state.tr\n                  .replaceRange(start, end, slice)\n                  .addMark(\n                    start,\n                    start + slice.size,\n                    state.schema.marks.code_inline.create()\n                  )\n              );\n              return true;\n            }\n\n            return false;\n          },\n        },\n      }),\n    ];\n  }\n\n  toMarkdown() {\n    return {\n      open(\n        _state: MarkdownSerializerState,\n        _mark: ProsemirrorMark,\n        parent: ProsemirrorNode,\n        index: number\n      ) {\n        return backticksFor(parent.child(index), -1);\n      },\n      close(\n        _state: MarkdownSerializerState,\n        _mark: ProsemirrorMark,\n        parent: ProsemirrorNode,\n        index: number\n      ) {\n        return backticksFor(parent.child(index - 1), 1);\n      },\n      escape: false,\n    };\n  }\n\n  parseMarkdown() {\n    return { mark: \"code_inline\" };\n  }\n}\n","/*\nCopyright 2020 Atlassian Pty Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n */\n\n// This file is based on the implementation found here:\n// https://bitbucket.org/atlassian/design-system-mirror/src/master/editor/editor-core/src/plugins/text-formatting/commands/text-formatting.ts\n\nimport { EditorState, TextSelection } from \"prosemirror-state\";\nimport isMarkActive from \"../queries/isMarkActive\";\nimport { Dispatch } from \"../types\";\n\nexport default function moveRight() {\n  return (state: EditorState, dispatch: Dispatch): boolean => {\n    const { code_inline } = state.schema.marks;\n    const { empty, $cursor } = state.selection as TextSelection;\n    if (!empty || !$cursor) {\n      return false;\n    }\n\n    const { storedMarks } = state.tr;\n    if (code_inline) {\n      const insideCode = isMarkActive(code_inline)(state);\n      const currentPosHasCode = state.doc.rangeHasMark(\n        $cursor.pos,\n        $cursor.pos,\n        code_inline\n      );\n      const nextPosHasCode = state.doc.rangeHasMark(\n        $cursor.pos,\n        $cursor.pos + 1,\n        code_inline\n      );\n\n      const exitingCode =\n        !currentPosHasCode &&\n        !nextPosHasCode &&\n        (!storedMarks || !!storedMarks.length);\n      const enteringCode =\n        !currentPosHasCode &&\n        nextPosHasCode &&\n        (!storedMarks || !storedMarks.length);\n\n      // entering code mark (from the left edge): don't move the cursor, just add the mark\n      if (!insideCode && enteringCode) {\n        dispatch(state.tr.addStoredMark(code_inline.create()));\n\n        return true;\n      }\n\n      // exiting code mark: don't move the cursor, just remove the mark\n      if (insideCode && exitingCode) {\n        dispatch(state.tr.removeStoredMark(code_inline));\n\n        return true;\n      }\n    }\n\n    return false;\n  };\n}\n","import { toggleMark } from \"prosemirror-commands\";\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { MarkSpec, MarkType } from \"prosemirror-model\";\nimport { Command } from \"../lib/Extension\";\nimport markInputRule from \"../lib/markInputRule\";\nimport Mark from \"./Mark\";\n\nexport default class Italic extends Mark {\n  get name() {\n    return \"em\";\n  }\n\n  get schema(): MarkSpec {\n    return {\n      parseDOM: [\n        { tag: \"i\" },\n        { tag: \"em\" },\n        {\n          style: \"font-style\",\n          getAttrs: (value) => (value === \"italic\" ? null : false),\n        },\n      ],\n      toDOM: () => [\"em\"],\n    };\n  }\n\n  inputRules({ type }: { type: MarkType }): InputRule[] {\n    /**\n     * Due to use of snake_case strings common in docs the matching conditions\n     * are a bit more strict than e.g. the ** bold syntax to help prevent\n     * false positives.\n     *\n     * Matches:\n     * _1_\n     * _123_\n     * (_one_\n     * [_one_\n     *\n     * No match:\n     * __\n     * __123_\n     * __123__\n     * _123\n     * one_123_\n     * ONE_123_\n     * 1_123_\n     */\n    return [\n      markInputRule(/(?:^|[^_a-zA-Z0-9])(_([^_]+)_)$/, type),\n      markInputRule(/(?:^|[^*a-zA-Z0-9])(\\*([^*]+)\\*)$/, type),\n    ];\n  }\n\n  keys({ type }: { type: MarkType }): Record<string, Command> {\n    return {\n      \"Mod-i\": toggleMark(type),\n      \"Mod-I\": toggleMark(type),\n    };\n  }\n\n  toMarkdown() {\n    return {\n      open: \"*\",\n      close: \"*\",\n      mixable: true,\n      expelEnclosingWhitespace: true,\n    };\n  }\n\n  parseMarkdown() {\n    return { mark: \"em\" };\n  }\n}\n","import Token from \"markdown-it/lib/token\";\nimport { OpenIcon } from \"outline-icons\";\nimport { toggleMark } from \"prosemirror-commands\";\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { MarkdownSerializerState } from \"prosemirror-markdown\";\nimport {\n  MarkSpec,\n  MarkType,\n  Node,\n  Mark as ProsemirrorMark,\n} from \"prosemirror-model\";\nimport { EditorState, Plugin } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport * as React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { isExternalUrl } from \"../../utils/urls\";\nimport findLinkNodes from \"../queries/findLinkNodes\";\nimport { EventType, Dispatch } from \"../types\";\nimport Mark from \"./Mark\";\n\nconst LINK_INPUT_REGEX = /\\[([^[]+)]\\((\\S+)\\)$/;\nlet icon: HTMLSpanElement;\n\nif (typeof window !== \"undefined\") {\n  const component = <OpenIcon color=\"currentColor\" size={16} />;\n  icon = document.createElement(\"span\");\n  icon.className = \"external-link\";\n  ReactDOM.render(component, icon);\n}\n\nfunction isPlainURL(\n  link: ProsemirrorMark,\n  parent: Node,\n  index: number,\n  side: -1 | 1\n) {\n  if (link.attrs.title || !/^\\w+:/.test(link.attrs.href)) {\n    return false;\n  }\n\n  const content = parent.child(index + (side < 0 ? -1 : 0));\n  if (\n    !content.isText ||\n    content.text !== link.attrs.href ||\n    content.marks[content.marks.length - 1] !== link\n  ) {\n    return false;\n  }\n\n  if (index === (side < 0 ? 1 : parent.childCount - 1)) {\n    return true;\n  }\n\n  const next = parent.child(index + (side < 0 ? -2 : 1));\n  return !link.isInSet(next.marks);\n}\n\nexport default class Link extends Mark {\n  get name() {\n    return \"link\";\n  }\n\n  get schema(): MarkSpec {\n    return {\n      attrs: {\n        href: {\n          default: \"\",\n        },\n      },\n      inclusive: false,\n      parseDOM: [\n        {\n          tag: \"a[href]\",\n          getAttrs: (dom: HTMLElement) => ({\n            href: dom.getAttribute(\"href\"),\n          }),\n        },\n      ],\n      toDOM: (node) => [\n        \"a\",\n        {\n          ...node.attrs,\n          rel: \"noopener noreferrer nofollow\",\n        },\n        0,\n      ],\n    };\n  }\n\n  inputRules({ type }: { type: MarkType }) {\n    return [\n      new InputRule(LINK_INPUT_REGEX, (state, match, start, end) => {\n        const [okay, alt, href] = match;\n        const { tr } = state;\n\n        if (okay) {\n          tr.replaceWith(start, end, this.editor.schema.text(alt)).addMark(\n            start,\n            start + alt.length,\n            type.create({ href })\n          );\n        }\n\n        return tr;\n      }),\n    ];\n  }\n\n  commands({ type }: { type: MarkType }) {\n    return ({ href } = { href: \"\" }) => toggleMark(type, { href });\n  }\n\n  keys({ type }: { type: MarkType }) {\n    return {\n      \"Mod-k\": (state: EditorState, dispatch: Dispatch) => {\n        if (state.selection.empty) {\n          this.editor.events.emit(EventType.linkMenuOpen);\n          return true;\n        }\n\n        return toggleMark(type, { href: \"\" })(state, dispatch);\n      },\n    };\n  }\n\n  get plugins() {\n    const getLinkDecorations = (state: EditorState) => {\n      const decorations: Decoration[] = [];\n      const links = findLinkNodes(state.doc);\n\n      links.forEach((nodeWithPos) => {\n        const linkMark = nodeWithPos.node.marks.find(\n          (mark) => mark.type.name === \"link\"\n        );\n        if (linkMark && isExternalUrl(linkMark.attrs.href)) {\n          decorations.push(\n            Decoration.widget(\n              // place the decoration at the end of the link\n              nodeWithPos.pos + nodeWithPos.node.nodeSize,\n              () => icon.cloneNode(true),\n              {\n                // position on the right side of the position\n                side: 1,\n                key: \"external-link\",\n              }\n            )\n          );\n        }\n      });\n\n      return DecorationSet.create(state.doc, decorations);\n    };\n\n    const plugin: Plugin = new Plugin({\n      state: {\n        init: (config, state) => {\n          return getLinkDecorations(state);\n        },\n        apply: (tr, decorationSet, _oldState, newState) => {\n          return tr.docChanged ? getLinkDecorations(newState) : decorationSet;\n        },\n      },\n      props: {\n        decorations: (state) => plugin.getState(state),\n        handleDOMEvents: {\n          mouseover: (view, event: MouseEvent) => {\n            if (\n              event.target instanceof HTMLAnchorElement &&\n              !event.target.className.includes(\"ProseMirror-widget\") &&\n              (!view.editable || (view.editable && !view.hasFocus()))\n            ) {\n              if (this.options.onHoverLink) {\n                return this.options.onHoverLink(event);\n              }\n            }\n            return false;\n          },\n          mousedown: (view, event: MouseEvent) => {\n            if (\n              !(event.target instanceof HTMLAnchorElement) ||\n              event.button !== 0\n            ) {\n              return false;\n            }\n\n            if (event.target.matches(\".component-attachment *\")) {\n              return false;\n            }\n\n            // clicking a link while editing should show the link toolbar,\n            // clicking in read-only will navigate\n            if (!view.editable || (view.editable && !view.hasFocus())) {\n              const href =\n                event.target.href ||\n                (event.target.parentNode instanceof HTMLAnchorElement\n                  ? event.target.parentNode.href\n                  : \"\");\n\n              const isHashtag = href.startsWith(\"#\");\n              if (isHashtag && this.options.onClickHashtag) {\n                event.stopPropagation();\n                event.preventDefault();\n                this.options.onClickHashtag(href, event);\n              }\n\n              if (this.options.onClickLink) {\n                event.stopPropagation();\n                event.preventDefault();\n                this.options.onClickLink(href, event);\n              }\n              return true;\n            }\n\n            return false;\n          },\n          click: (view, event) => {\n            if (\n              !(event.target instanceof HTMLAnchorElement) ||\n              event.button !== 0\n            ) {\n              return false;\n            }\n\n            if (event.target.matches(\".component-attachment *\")) {\n              return false;\n            }\n\n            // Prevent all default click behavior of links, see mousedown above\n            // for custom link handling.\n            if (this.options.onClickLink) {\n              event.stopPropagation();\n              event.preventDefault();\n            }\n\n            return false;\n          },\n        },\n      },\n    });\n\n    return [plugin];\n  }\n\n  toMarkdown() {\n    return {\n      open(\n        _state: MarkdownSerializerState,\n        mark: ProsemirrorMark,\n        parent: Node,\n        index: number\n      ) {\n        return isPlainURL(mark, parent, index, 1) ? \"<\" : \"[\";\n      },\n      close(\n        state: MarkdownSerializerState,\n        mark: ProsemirrorMark,\n        parent: Node,\n        index: number\n      ) {\n        return isPlainURL(mark, parent, index, -1)\n          ? \">\"\n          : \"](\" +\n              state.esc(mark.attrs.href) +\n              (mark.attrs.title ? \" \" + state.quote(mark.attrs.title) : \"\") +\n              \")\";\n      },\n    };\n  }\n\n  parseMarkdown() {\n    return {\n      mark: \"link\",\n      getAttrs: (tok: Token) => ({\n        href: tok.attrGet(\"href\"),\n        title: tok.attrGet(\"title\") || null,\n      }),\n    };\n  }\n}\n","import { Node } from \"prosemirror-model\";\nimport { findTextNodes, NodeWithPos } from \"prosemirror-utils\";\n\nexport default function findLinkNodes(doc: Node): NodeWithPos[] {\n  const textNodes = findTextNodes(doc);\n  const nodes: NodeWithPos[] = [];\n\n  for (const nodeWithPos of textNodes) {\n    const hasLinkMark = nodeWithPos.node.marks.find(\n      (mark) => mark.type.name === \"link\"\n    );\n\n    if (hasLinkMark) {\n      nodes.push(nodeWithPos);\n    }\n  }\n\n  return nodes;\n}\n","import { toggleMark } from \"prosemirror-commands\";\nimport { MarkSpec, MarkType } from \"prosemirror-model\";\nimport markInputRule from \"../lib/markInputRule\";\nimport Mark from \"./Mark\";\n\nexport default class Strikethrough extends Mark {\n  get name() {\n    return \"strikethrough\";\n  }\n\n  get schema(): MarkSpec {\n    return {\n      parseDOM: [\n        {\n          tag: \"s\",\n        },\n        {\n          tag: \"del\",\n        },\n        {\n          tag: \"strike\",\n        },\n        {\n          style: \"text-decoration\",\n          getAttrs: (value) => (value === \"line-through\" ? null : false),\n        },\n      ],\n      toDOM: () => [\"del\", 0],\n    };\n  }\n\n  keys({ type }: { type: MarkType }) {\n    return {\n      \"Mod-d\": toggleMark(type),\n    };\n  }\n\n  inputRules({ type }: { type: MarkType }) {\n    return [markInputRule(/~([^~]+)~$/, type)];\n  }\n\n  toMarkdown() {\n    return {\n      open: \"~~\",\n      close: \"~~\",\n      mixable: true,\n      expelEnclosingWhitespace: true,\n    };\n  }\n\n  get markdownToken() {\n    return \"s\";\n  }\n\n  parseMarkdown() {\n    return { mark: \"strikethrough\" };\n  }\n}\n","import MarkdownIt from \"markdown-it\";\n\nexport default function markdownUnderlines(md: MarkdownIt) {\n  md.inline.ruler2.after(\"emphasis\", \"underline\", (state) => {\n    const tokens = state.tokens;\n\n    for (let i = tokens.length - 1; i > 0; i--) {\n      const token = tokens[i];\n\n      if (token.markup === \"__\") {\n        if (token.type === \"strong_open\") {\n          tokens[i].tag = \"underline\";\n          tokens[i].type = \"underline_open\";\n        }\n        if (token.type === \"strong_close\") {\n          tokens[i].tag = \"underline\";\n          tokens[i].type = \"underline_close\";\n        }\n      }\n    }\n\n    return false;\n  });\n}\n","import { toggleMark } from \"prosemirror-commands\";\nimport { MarkSpec, MarkType } from \"prosemirror-model\";\nimport markInputRule from \"../lib/markInputRule\";\nimport underlinesRule from \"../rules/underlines\";\nimport Mark from \"./Mark\";\n\nexport default class Underline extends Mark {\n  get name() {\n    return \"underline\";\n  }\n\n  get schema(): MarkSpec {\n    return {\n      parseDOM: [\n        { tag: \"u\" },\n        {\n          style: \"text-decoration\",\n          getAttrs: (value) => (value === \"underline\" ? null : false),\n        },\n      ],\n      toDOM: () => [\"u\", 0],\n    };\n  }\n\n  get rulePlugins() {\n    return [underlinesRule];\n  }\n\n  inputRules({ type }: { type: MarkType }) {\n    return [markInputRule(/(?:__)([^_]+)(?:__)$/, type)];\n  }\n\n  keys({ type }: { type: MarkType }) {\n    return {\n      \"Mod-u\": toggleMark(type),\n    };\n  }\n\n  toMarkdown() {\n    return {\n      open: \"__\",\n      close: \"__\",\n      mixable: true,\n      expelEnclosingWhitespace: true,\n    };\n  }\n\n  parseMarkdown() {\n    return { mark: \"underline\" };\n  }\n}\n","import { NodeSpec } from \"prosemirror-model\";\nimport Node from \"./Node\";\n\nexport default class Doc extends Node {\n  get name() {\n    return \"doc\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      content: \"block+\",\n    };\n  }\n}\n","import nameToEmoji from \"gemoji/name-to-emoji.json\";\nimport MarkdownIt from \"markdown-it\";\nimport emojiPlugin from \"markdown-it-emoji\";\n\nexport default function emoji(md: MarkdownIt) {\n  // Ideally this would be an empty object, but due to a bug in markdown-it-emoji\n  // passing an empty object results in newlines becoming emojis. Until this is\n  // fixed at least one key is required. See:\n  // https://github.com/markdown-it/markdown-it-emoji/issues/46\n  const noMapping = {\n    no_name_mapping: \"💯\",\n  };\n\n  return emojiPlugin(md, {\n    defs: (md.options as any).emoji === false ? noMapping : nameToEmoji,\n    shortcuts: {},\n  });\n}\n","import nameToEmoji from \"gemoji/name-to-emoji.json\";\nimport Token from \"markdown-it/lib/token\";\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { NodeSpec, Node as ProsemirrorNode, NodeType } from \"prosemirror-model\";\nimport { EditorState, TextSelection, Plugin } from \"prosemirror-state\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport { run } from \"../plugins/BlockMenuTrigger\";\nimport isInCode from \"../queries/isInCode\";\nimport emojiRule from \"../rules/emoji\";\nimport { Dispatch, EventType } from \"../types\";\nimport Node from \"./Node\";\n\nconst OPEN_REGEX = /(?:^|\\s):([0-9a-zA-Z_+-]+)?$/;\nconst CLOSE_REGEX = /(?:^|\\s):(([0-9a-zA-Z_+-]*\\s+)|(\\s+[0-9a-zA-Z_+-]+)|[^0-9a-zA-Z_+-]+)$/;\n\nexport default class Emoji extends Node {\n  get name() {\n    return \"emoji\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      attrs: {\n        style: {\n          default: \"\",\n        },\n        \"data-name\": {\n          default: undefined,\n        },\n      },\n      inline: true,\n      content: \"text*\",\n      marks: \"\",\n      group: \"inline\",\n      selectable: false,\n      parseDOM: [\n        {\n          tag: \"span.emoji\",\n          preserveWhitespace: \"full\",\n          getAttrs: (dom: HTMLDivElement) => ({\n            \"data-name\": dom.dataset.name,\n          }),\n        },\n      ],\n      toDOM: (node) => {\n        if (nameToEmoji[node.attrs[\"data-name\"]]) {\n          const text = document.createTextNode(\n            nameToEmoji[node.attrs[\"data-name\"]]\n          );\n          return [\n            \"span\",\n            {\n              class: `emoji ${node.attrs[\"data-name\"]}`,\n              \"data-name\": node.attrs[\"data-name\"],\n            },\n            text,\n          ];\n        }\n        const text = document.createTextNode(`:${node.attrs[\"data-name\"]}:`);\n        return [\"span\", { class: \"emoji\" }, text];\n      },\n      toPlainText: (node) => nameToEmoji[node.attrs[\"data-name\"]],\n    };\n  }\n\n  get rulePlugins() {\n    return [emojiRule];\n  }\n\n  get plugins() {\n    return [\n      new Plugin({\n        props: {\n          handleClick: () => {\n            this.editor.events.emit(EventType.emojiMenuClose);\n            return false;\n          },\n          handleKeyDown: (view, event) => {\n            // Prosemirror input rules are not triggered on backspace, however\n            // we need them to be evaluted for the filter trigger to work\n            // correctly. This additional handler adds inputrules-like handling.\n            if (event.key === \"Backspace\") {\n              // timeout ensures that the delete has been handled by prosemirror\n              // and any characters removed, before we evaluate the rule.\n              setTimeout(() => {\n                const { pos } = view.state.selection.$from;\n                return run(view, pos, pos, OPEN_REGEX, (state, match) => {\n                  if (match) {\n                    this.editor.events.emit(EventType.emojiMenuOpen, match[1]);\n                  } else {\n                    this.editor.events.emit(EventType.emojiMenuClose);\n                  }\n                  return null;\n                });\n              });\n            }\n\n            // If the query is active and we're navigating the block menu then\n            // just ignore the key events in the editor itself until we're done\n            if (\n              event.key === \"Enter\" ||\n              event.key === \"ArrowUp\" ||\n              event.key === \"ArrowDown\" ||\n              event.key === \"Tab\"\n            ) {\n              const { pos } = view.state.selection.$from;\n\n              return run(view, pos, pos, OPEN_REGEX, (state, match) => {\n                // just tell Prosemirror we handled it and not to do anything\n                return match ? true : null;\n              });\n            }\n\n            return false;\n          },\n        },\n      }),\n    ];\n  }\n\n  commands({ type }: { type: NodeType }) {\n    return (attrs: Record<string, string>) => (\n      state: EditorState,\n      dispatch: Dispatch\n    ) => {\n      const { selection } = state;\n      const position =\n        selection instanceof TextSelection\n          ? selection.$cursor?.pos\n          : selection.$to.pos;\n      if (position === undefined) {\n        return false;\n      }\n\n      const node = type.create(attrs);\n      const transaction = state.tr.insert(position, node);\n      dispatch(transaction);\n      return true;\n    };\n  }\n\n  inputRules({ type }: { type: NodeType }): InputRule[] {\n    return [\n      new InputRule(/^:([a-zA-Z0-9_+-]+):$/, (state, match, start, end) => {\n        const [okay, markup] = match;\n        const { tr } = state;\n        if (okay) {\n          tr.replaceWith(\n            start - 1,\n            end,\n            type.create({\n              \"data-name\": markup,\n              markup,\n            })\n          );\n        }\n\n        return tr;\n      }),\n      // main regex should match only:\n      // :word\n      new InputRule(OPEN_REGEX, (state, match) => {\n        if (\n          match &&\n          state.selection.$from.parent.type.name === \"paragraph\" &&\n          !isInCode(state)\n        ) {\n          this.editor.events.emit(EventType.emojiMenuOpen, match[1]);\n        }\n        return null;\n      }),\n      // invert regex should match some of these scenarios:\n      // :<space>word\n      // :<space>\n      // :word<space>\n      // :)\n      new InputRule(CLOSE_REGEX, (state, match) => {\n        if (match) {\n          this.editor.events.emit(EventType.emojiMenuClose);\n        }\n        return null;\n      }),\n    ];\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    const name = node.attrs[\"data-name\"];\n    if (name) {\n      state.write(`:${name}:`);\n    }\n  }\n\n  parseMarkdown() {\n    return {\n      node: \"emoji\",\n      getAttrs: (tok: Token) => {\n        return { \"data-name\": tok.markup.trim() };\n      },\n    };\n  }\n}\n","import MarkdownIt from \"markdown-it\";\nimport Token from \"markdown-it/lib/token\";\n\nfunction isHardbreak(token: Token) {\n  return (\n    token.type === \"hardbreak\" ||\n    (token.type === \"text\" && token.content === \"\\\\\")\n  );\n}\n\nexport default function markdownBreakToParagraphs(md: MarkdownIt) {\n  // insert a new rule after the \"inline\" rules are parsed\n  md.core.ruler.after(\"inline\", \"breaks\", (state) => {\n    const { Token } = state;\n    const tokens = state.tokens;\n\n    // work backwards through the tokens and find text that looks like a br\n    for (let i = tokens.length - 1; i > 0; i--) {\n      const tokenChildren = tokens[i].children || [];\n      const matches = tokenChildren.filter(isHardbreak);\n\n      if (matches.length) {\n        let token;\n\n        const nodes: Token[] = [];\n        const children = tokenChildren.filter((child) => !isHardbreak(child));\n\n        let count = matches.length;\n        if (children.length) {\n          count++;\n        }\n\n        for (let i = 0; i < count; i++) {\n          const isLast = i === count - 1;\n\n          token = new Token(\"paragraph_open\", \"p\", 1);\n          nodes.push(token);\n\n          const text = new Token(\"text\", \"\", 0);\n          text.content = \"\";\n\n          token = new Token(\"inline\", \"\", 0);\n          token.level = 1;\n          token.children = isLast ? [text, ...children] : [text];\n          token.content = \"\";\n          nodes.push(token);\n\n          token = new Token(\"paragraph_close\", \"p\", -1);\n          nodes.push(token);\n        }\n\n        tokens.splice(i - 1, 3, ...nodes);\n      }\n    }\n\n    return false;\n  });\n}\n","import { NodeSpec, NodeType } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\nimport { isInTable } from \"prosemirror-tables\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport breakRule from \"../rules/breaks\";\nimport { Dispatch } from \"../types\";\nimport Node from \"./Node\";\n\nexport default class HardBreak extends Node {\n  get name() {\n    return \"br\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      inline: true,\n      group: \"inline\",\n      selectable: false,\n      parseDOM: [{ tag: \"br\" }],\n      toDOM: () => [\"br\"],\n      toPlainText: () => \"\\n\",\n    };\n  }\n\n  get rulePlugins() {\n    return [breakRule];\n  }\n\n  commands({ type }: { type: NodeType }) {\n    return () => (state: EditorState, dispatch: Dispatch) => {\n      dispatch(state.tr.replaceSelectionWith(type.create()).scrollIntoView());\n      return true;\n    };\n  }\n\n  keys({ type }: { type: NodeType }) {\n    return {\n      \"Shift-Enter\": (state: EditorState, dispatch: Dispatch) => {\n        if (!isInTable(state)) {\n          return false;\n        }\n        dispatch(state.tr.replaceSelectionWith(type.create()).scrollIntoView());\n        return true;\n      },\n    };\n  }\n\n  toMarkdown(state: MarkdownSerializerState) {\n    state.write(\" \\\\n \");\n  }\n\n  parseMarkdown() {\n    return { node: \"br\" };\n  }\n}\n","import Token from \"markdown-it/lib/token\";\nimport { DownloadIcon } from \"outline-icons\";\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { Node as ProsemirrorNode, NodeSpec, NodeType } from \"prosemirror-model\";\nimport {\n  Plugin,\n  TextSelection,\n  NodeSelection,\n  EditorState,\n} from \"prosemirror-state\";\nimport * as React from \"react\";\nimport ImageZoom from \"react-medium-image-zoom\";\nimport styled from \"styled-components\";\nimport { supportedImageMimeTypes } from \"../../utils/files\";\nimport getDataTransferFiles from \"../../utils/getDataTransferFiles\";\nimport insertFiles, { Options } from \"../commands/insertFiles\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport uploadPlaceholderPlugin from \"../lib/uploadPlaceholder\";\nimport { ComponentProps, Dispatch } from \"../types\";\nimport Node from \"./Node\";\n\n/**\n * Matches following attributes in Markdown-typed image: [, alt, src, class]\n *\n * Example:\n * ![Lorem](image.jpg) -> [, \"Lorem\", \"image.jpg\"]\n * ![](image.jpg \"class\") -> [, \"\", \"image.jpg\", \"small\"]\n * ![Lorem](image.jpg \"class\") -> [, \"Lorem\", \"image.jpg\", \"small\"]\n */\nconst IMAGE_INPUT_REGEX = /!\\[(?<alt>[^\\][]*?)]\\((?<filename>[^\\][]*?)(?=“|\\))“?(?<layoutclass>[^\\][”]+)?”?\\)$/;\n\nconst uploadPlugin = (options: Options) =>\n  new Plugin({\n    props: {\n      handleDOMEvents: {\n        paste(view, event: ClipboardEvent): boolean {\n          if (\n            (view.props.editable && !view.props.editable(view.state)) ||\n            !options.uploadFile\n          ) {\n            return false;\n          }\n\n          if (!event.clipboardData) {\n            return false;\n          }\n\n          // check if we actually pasted any files\n          const files = Array.prototype.slice\n            .call(event.clipboardData.items)\n            .filter((dt: DataTransferItem) => dt.kind !== \"string\")\n            .map((dt: DataTransferItem) => dt.getAsFile())\n            .filter(Boolean);\n\n          if (files.length === 0) {\n            return false;\n          }\n\n          const { tr } = view.state;\n          if (!tr.selection.empty) {\n            tr.deleteSelection();\n          }\n          const pos = tr.selection.from;\n\n          insertFiles(view, event, pos, files, options);\n          return true;\n        },\n        drop(view, event: DragEvent): boolean {\n          if (\n            (view.props.editable && !view.props.editable(view.state)) ||\n            !options.uploadFile\n          ) {\n            return false;\n          }\n\n          // filter to only include image files\n          const files = getDataTransferFiles(event).filter(\n            (dt: any) => dt.kind !== \"string\"\n          );\n          if (files.length === 0) {\n            return false;\n          }\n\n          // grab the position in the document for the cursor\n          const result = view.posAtCoords({\n            left: event.clientX,\n            top: event.clientY,\n          });\n\n          if (result) {\n            insertFiles(view, event, result.pos, files, options);\n            return true;\n          }\n\n          return false;\n        },\n      },\n    },\n  });\n\nconst IMAGE_CLASSES = [\"right-50\", \"left-50\"];\n\nconst getLayoutAndTitle = (tokenTitle: string | null) => {\n  if (!tokenTitle) {\n    return {};\n  }\n  if (IMAGE_CLASSES.includes(tokenTitle)) {\n    return {\n      layoutClass: tokenTitle,\n    };\n  } else {\n    return {\n      title: tokenTitle,\n    };\n  }\n};\n\nconst downloadImageNode = async (node: ProsemirrorNode) => {\n  const image = await fetch(node.attrs.src);\n  const imageBlob = await image.blob();\n  const imageURL = URL.createObjectURL(imageBlob);\n  const extension = imageBlob.type.split(\"/\")[1];\n  const potentialName = node.attrs.alt || \"image\";\n\n  // create a temporary link node and click it with our image data\n  const link = document.createElement(\"a\");\n  link.href = imageURL;\n  link.download = `${potentialName}.${extension}`;\n  document.body.appendChild(link);\n  link.click();\n\n  // cleanup\n  document.body.removeChild(link);\n};\n\nexport default class Image extends Node {\n  options: Options;\n\n  get name() {\n    return \"image\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      inline: true,\n      attrs: {\n        src: {},\n        alt: {\n          default: null,\n        },\n        layoutClass: {\n          default: null,\n        },\n        title: {\n          default: null,\n        },\n      },\n      content: \"text*\",\n      marks: \"\",\n      group: \"inline\",\n      selectable: true,\n      draggable: true,\n      parseDOM: [\n        {\n          tag: \"div[class~=image]\",\n          getAttrs: (dom: HTMLDivElement) => {\n            const img = dom.getElementsByTagName(\"img\")[0];\n            const className = dom.className;\n            const layoutClassMatched =\n              className && className.match(/image-(.*)$/);\n            const layoutClass = layoutClassMatched\n              ? layoutClassMatched[1]\n              : null;\n            return {\n              src: img?.getAttribute(\"src\"),\n              alt: img?.getAttribute(\"alt\"),\n              title: img?.getAttribute(\"title\"),\n              layoutClass: layoutClass,\n            };\n          },\n        },\n        {\n          tag: \"img\",\n          getAttrs: (dom: HTMLImageElement) => {\n            return {\n              src: dom.getAttribute(\"src\"),\n              alt: dom.getAttribute(\"alt\"),\n              title: dom.getAttribute(\"title\"),\n            };\n          },\n        },\n      ],\n      toDOM: (node) => {\n        const className = node.attrs.layoutClass\n          ? `image image-${node.attrs.layoutClass}`\n          : \"image\";\n        return [\n          \"div\",\n          {\n            class: className,\n          },\n          [\"img\", { ...node.attrs, contentEditable: \"false\" }],\n          [\"p\", { class: \"caption\" }, 0],\n        ];\n      },\n    };\n  }\n\n  handleKeyDown = ({\n    node,\n    getPos,\n  }: {\n    node: ProsemirrorNode;\n    getPos: () => number;\n  }) => (event: React.KeyboardEvent<HTMLSpanElement>) => {\n    // Pressing Enter in the caption field should move the cursor/selection\n    // below the image\n    if (event.key === \"Enter\") {\n      event.preventDefault();\n\n      const { view } = this.editor;\n      const $pos = view.state.doc.resolve(getPos() + node.nodeSize);\n      view.dispatch(\n        view.state.tr.setSelection(new TextSelection($pos)).split($pos.pos)\n      );\n      view.focus();\n      return;\n    }\n\n    // Pressing Backspace in an an empty caption field should remove the entire\n    // image, leaving an empty paragraph\n    if (event.key === \"Backspace\" && event.currentTarget.innerText === \"\") {\n      const { view } = this.editor;\n      const $pos = view.state.doc.resolve(getPos());\n      const tr = view.state.tr.setSelection(new NodeSelection($pos));\n      view.dispatch(tr.deleteSelection());\n      view.focus();\n      return;\n    }\n  };\n\n  handleBlur = ({\n    node,\n    getPos,\n  }: {\n    node: ProsemirrorNode;\n    getPos: () => number;\n  }) => (event: React.FocusEvent<HTMLSpanElement>) => {\n    const alt = event.currentTarget.innerText;\n    const { src, title, layoutClass } = node.attrs;\n\n    if (alt === node.attrs.alt) {\n      return;\n    }\n\n    const { view } = this.editor;\n    const { tr } = view.state;\n\n    // update meta on object\n    const pos = getPos();\n    const transaction = tr.setNodeMarkup(pos, undefined, {\n      src,\n      alt,\n      title,\n      layoutClass,\n    });\n    view.dispatch(transaction);\n  };\n\n  handleSelect = ({ getPos }: { getPos: () => number }) => (\n    event: React.MouseEvent\n  ) => {\n    event.preventDefault();\n\n    const { view } = this.editor;\n    const $pos = view.state.doc.resolve(getPos());\n    const transaction = view.state.tr.setSelection(new NodeSelection($pos));\n    view.dispatch(transaction);\n  };\n\n  handleDownload = ({ node }: { node: ProsemirrorNode }) => (\n    event: React.MouseEvent\n  ) => {\n    event.preventDefault();\n    event.stopPropagation();\n    downloadImageNode(node);\n  };\n\n  handleMouseDown = (ev: React.MouseEvent<HTMLParagraphElement>) => {\n    if (document.activeElement !== ev.currentTarget) {\n      ev.preventDefault();\n      ev.stopPropagation();\n      ev.currentTarget.focus();\n    }\n  };\n\n  component = (props: ComponentProps) => {\n    return (\n      <ImageComponent\n        {...props}\n        onClick={this.handleSelect(props)}\n        onDownload={this.handleDownload(props)}\n      >\n        <Caption\n          onKeyDown={this.handleKeyDown(props)}\n          onBlur={this.handleBlur(props)}\n          onMouseDown={this.handleMouseDown}\n          className=\"caption\"\n          tabIndex={-1}\n          role=\"textbox\"\n          contentEditable\n          suppressContentEditableWarning\n          data-caption={this.options.dictionary.imageCaptionPlaceholder}\n        >\n          {props.node.attrs.alt}\n        </Caption>\n      </ImageComponent>\n    );\n  };\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    let markdown =\n      \" ![\" +\n      state.esc((node.attrs.alt || \"\").replace(\"\\n\", \"\") || \"\", false) +\n      \"](\" +\n      state.esc(node.attrs.src || \"\", false);\n    if (node.attrs.layoutClass) {\n      markdown += ' \"' + state.esc(node.attrs.layoutClass, false) + '\"';\n    } else if (node.attrs.title) {\n      markdown += ' \"' + state.esc(node.attrs.title, false) + '\"';\n    }\n    markdown += \")\";\n    state.write(markdown);\n  }\n\n  parseMarkdown() {\n    return {\n      node: \"image\",\n      getAttrs: (token: Token) => {\n        return {\n          src: token.attrGet(\"src\"),\n          alt:\n            (token?.children &&\n              token.children[0] &&\n              token.children[0].content) ||\n            null,\n          ...getLayoutAndTitle(token?.attrGet(\"title\")),\n        };\n      },\n    };\n  }\n\n  commands({ type }: { type: NodeType }) {\n    return {\n      downloadImage: () => (state: EditorState) => {\n        if (!(state.selection instanceof NodeSelection)) {\n          return false;\n        }\n        const { node } = state.selection;\n\n        if (node.type.name !== \"image\") {\n          return false;\n        }\n\n        downloadImageNode(node);\n\n        return true;\n      },\n      deleteImage: () => (state: EditorState, dispatch: Dispatch) => {\n        dispatch(state.tr.deleteSelection());\n        return true;\n      },\n      alignRight: () => (state: EditorState, dispatch: Dispatch) => {\n        if (!(state.selection instanceof NodeSelection)) {\n          return false;\n        }\n        const attrs = {\n          ...state.selection.node.attrs,\n          title: null,\n          layoutClass: \"right-50\",\n        };\n        const { selection } = state;\n        dispatch(state.tr.setNodeMarkup(selection.from, undefined, attrs));\n        return true;\n      },\n      alignLeft: () => (state: EditorState, dispatch: Dispatch) => {\n        if (!(state.selection instanceof NodeSelection)) {\n          return false;\n        }\n        const attrs = {\n          ...state.selection.node.attrs,\n          title: null,\n          layoutClass: \"left-50\",\n        };\n        const { selection } = state;\n        dispatch(state.tr.setNodeMarkup(selection.from, undefined, attrs));\n        return true;\n      },\n      replaceImage: () => (state: EditorState) => {\n        const { view } = this.editor;\n        const {\n          uploadFile,\n          onFileUploadStart,\n          onFileUploadStop,\n          onShowToast,\n        } = this.editor.props;\n\n        if (!uploadFile) {\n          throw new Error(\"uploadFile prop is required to replace images\");\n        }\n\n        // create an input element and click to trigger picker\n        const inputElement = document.createElement(\"input\");\n        inputElement.type = \"file\";\n        inputElement.accept = supportedImageMimeTypes.join(\", \");\n        inputElement.onchange = (event: Event) => {\n          const files = getDataTransferFiles(event);\n          insertFiles(view, event, state.selection.from, files, {\n            uploadFile,\n            onFileUploadStart,\n            onFileUploadStop,\n            onShowToast,\n            dictionary: this.options.dictionary,\n            replaceExisting: true,\n          });\n        };\n        inputElement.click();\n        return true;\n      },\n      alignCenter: () => (state: EditorState, dispatch: Dispatch) => {\n        if (!(state.selection instanceof NodeSelection)) {\n          return false;\n        }\n        const attrs = { ...state.selection.node.attrs, layoutClass: null };\n        const { selection } = state;\n        dispatch(state.tr.setNodeMarkup(selection.from, undefined, attrs));\n        return true;\n      },\n      createImage: (attrs: Record<string, any>) => (\n        state: EditorState,\n        dispatch: Dispatch\n      ) => {\n        const { selection } = state;\n        const position =\n          selection instanceof TextSelection\n            ? selection.$cursor?.pos\n            : selection.$to.pos;\n        if (position === undefined) {\n          return false;\n        }\n\n        const node = type.create(attrs);\n        const transaction = state.tr.insert(position, node);\n        dispatch(transaction);\n        return true;\n      },\n    };\n  }\n\n  inputRules({ type }: { type: NodeType }) {\n    return [\n      new InputRule(IMAGE_INPUT_REGEX, (state, match, start, end) => {\n        const [okay, alt, src, matchedTitle] = match;\n        const { tr } = state;\n\n        if (okay) {\n          tr.replaceWith(\n            start - 1,\n            end,\n            type.create({\n              src,\n              alt,\n              ...getLayoutAndTitle(matchedTitle),\n            })\n          );\n        }\n\n        return tr;\n      }),\n    ];\n  }\n\n  get plugins() {\n    return [uploadPlaceholderPlugin, uploadPlugin(this.options)];\n  }\n}\n\nconst ImageComponent = (\n  props: ComponentProps & {\n    onClick: (event: React.MouseEvent<HTMLDivElement>) => void;\n    onDownload: (event: React.MouseEvent<HTMLButtonElement>) => void;\n    children: React.ReactNode;\n  }\n) => {\n  const { theme, isSelected, node } = props;\n  const { alt, src, layoutClass } = node.attrs;\n  const className = layoutClass ? `image image-${layoutClass}` : \"image\";\n  const [width, setWidth] = React.useState(0);\n\n  return (\n    <div contentEditable={false} className={className}>\n      <ImageWrapper\n        className={isSelected ? \"ProseMirror-selectednode\" : \"\"}\n        onClick={props.onClick}\n        style={{ width }}\n      >\n        <Button onClick={props.onDownload}>\n          <DownloadIcon color=\"currentColor\" />\n        </Button>\n        <ImageZoom\n          image={{\n            src,\n            alt,\n            // @ts-expect-error type is incorrect, allows spreading all img props\n            onLoad: (ev) => {\n              // For some SVG's Firefox does not provide the naturalWidth, in this\n              // rare case we need to provide a default so that the image can be\n              // seen and is not sized to 0px\n              setWidth(ev.target.naturalWidth || \"50%\");\n            },\n          }}\n          defaultStyles={{\n            overlay: {\n              backgroundColor: theme.background,\n            },\n          }}\n          shouldRespectMaxDimension\n        />\n      </ImageWrapper>\n      {props.children}\n    </div>\n  );\n};\n\nconst Button = styled.button`\n  position: absolute;\n  top: 8px;\n  right: 8px;\n  border: 0;\n  margin: 0;\n  padding: 0;\n  border-radius: 4px;\n  background: ${(props) => props.theme.background};\n  color: ${(props) => props.theme.textSecondary};\n  width: 24px;\n  height: 24px;\n  display: inline-block;\n  cursor: pointer;\n  opacity: 0;\n  transition: opacity 100ms ease-in-out;\n\n  &:active {\n    transform: scale(0.98);\n  }\n\n  &:hover {\n    color: ${(props) => props.theme.text};\n    opacity: 1;\n  }\n`;\n\nconst Caption = styled.p`\n  border: 0;\n  display: block;\n  font-size: 13px;\n  font-style: italic;\n  font-weight: normal;\n  color: ${(props) => props.theme.textSecondary};\n  padding: 8px 0 4px;\n  line-height: 16px;\n  text-align: center;\n  min-height: 1em;\n  outline: none;\n  background: none;\n  resize: none;\n  user-select: text;\n  margin: 0 !important;\n  cursor: text;\n\n  &:empty:not(:focus) {\n    display: none;\n  }\n\n  &:empty:before {\n    color: ${(props) => props.theme.placeholder};\n    content: attr(data-caption);\n    pointer-events: none;\n  }\n`;\n\nconst ImageWrapper = styled.div`\n  line-height: 0;\n  position: relative;\n  margin-left: auto;\n  margin-right: auto;\n  max-width: 100%;\n\n  &:hover {\n    ${Button} {\n      opacity: 0.9;\n    }\n  }\n\n  &.ProseMirror-selectednode + ${Caption} {\n    display: block;\n  }\n`;\n","import { setBlockType } from \"prosemirror-commands\";\nimport { NodeSpec, NodeType, Node as ProsemirrorNode } from \"prosemirror-model\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport Node from \"./Node\";\n\nexport default class Paragraph extends Node {\n  get name() {\n    return \"paragraph\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      content: \"inline*\",\n      group: \"block\",\n      parseDOM: [{ tag: \"p\" }],\n      toDOM: () => [\"p\", 0],\n    };\n  }\n\n  keys({ type }: { type: NodeType }) {\n    return {\n      \"Shift-Ctrl-0\": setBlockType(type),\n    };\n  }\n\n  commands({ type }: { type: NodeType }) {\n    return () => setBlockType(type);\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    // render empty paragraphs as hard breaks to ensure that newlines are\n    // persisted between reloads (this breaks from markdown tradition)\n    if (\n      node.textContent.trim() === \"\" &&\n      node.childCount === 0 &&\n      !state.inTable\n    ) {\n      state.write(\"\\\\\\n\");\n    } else {\n      state.renderInline(node);\n      state.closeBlock(node);\n    }\n  }\n\n  parseMarkdown() {\n    return { block: \"paragraph\" };\n  }\n}\n","import { Node as ProsemirrorNode, NodeSpec } from \"prosemirror-model\";\nimport { MarkdownSerializerState } from \"../lib/markdown/serializer\";\nimport Node from \"./Node\";\n\nexport default class Text extends Node {\n  get name() {\n    return \"text\";\n  }\n\n  get schema(): NodeSpec {\n    return {\n      group: \"inline\",\n    };\n  }\n\n  toMarkdown(state: MarkdownSerializerState, node: ProsemirrorNode) {\n    state.text(node.text || \"\", undefined);\n  }\n}\n","import { Plugin, PluginKey } from \"prosemirror-state\";\nimport Extension from \"../lib/Extension\";\nimport textBetween from \"../lib/textBetween\";\n\n/**\n * A plugin that allows overriding the default behavior of the editor to allow\n * copying text for nodes that do not inherently have text children by defining\n * a `toPlainText` method in the node spec.\n */\nexport default class ClipboardTextSerializer extends Extension {\n  get name() {\n    return \"clipboardTextSerializer\";\n  }\n\n  get plugins() {\n    const textSerializers = Object.fromEntries(\n      Object.entries(this.editor.schema.nodes)\n        .filter(([, node]) => node.spec.toPlainText)\n        .map(([name, node]) => [name, node.spec.toPlainText])\n    );\n\n    return [\n      new Plugin({\n        key: new PluginKey(\"clipboardTextSerializer\"),\n        props: {\n          clipboardTextSerializer: () => {\n            const { doc, selection } = this.editor.view.state;\n            const { ranges } = selection;\n            const from = Math.min(...ranges.map((range) => range.$from.pos));\n            const to = Math.max(...ranges.map((range) => range.$to.pos));\n\n            return textBetween(doc, from, to, textSerializers);\n          },\n        },\n      }),\n    ];\n  }\n}\n","import { Node as ProseMirrorNode } from \"prosemirror-model\";\nimport { PlainTextSerializer } from \"../types\";\n\n/**\n * Returns the text content between two positions.\n *\n * @param doc The Prosemirror document to use\n * @param from A start point\n * @param to An end point\n * @param plainTextSerializers A map of node names to PlainTextSerializers which convert a node to plain text\n * @returns A string of plain text\n */\nexport default function textBetween(\n  doc: ProseMirrorNode,\n  from: number,\n  to: number,\n  plainTextSerializers: Record<string, PlainTextSerializer | undefined>\n): string {\n  const blockSeparator = \"\\n\\n\";\n  let text = \"\";\n  let separated = true;\n\n  doc.nodesBetween(from, to, (node, pos) => {\n    const toPlainText = plainTextSerializers[node.type.name];\n\n    if (toPlainText) {\n      if (node.isBlock && !separated) {\n        text += blockSeparator;\n        separated = true;\n      }\n\n      text += toPlainText(node);\n    } else if (node.isText) {\n      text += node.text?.slice(Math.max(from, pos) - pos, to - pos);\n      separated = false;\n    } else if (node.isBlock && !separated) {\n      text += blockSeparator;\n      separated = true;\n    }\n  });\n\n  return text;\n}\n","import { InputRule } from \"prosemirror-inputrules\";\nimport { Schema } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\nimport {\n  getCurrentDateAsString,\n  getCurrentDateTimeAsString,\n  getCurrentTimeAsString,\n} from \"../../utils/date\";\nimport Extension from \"../lib/Extension\";\nimport { Dispatch, EventType } from \"../types\";\n\n/**\n * An editor extension that adds commands to insert the current date and time.\n */\nexport default class DateTime extends Extension {\n  get name() {\n    return \"date_time\";\n  }\n\n  inputRules() {\n    return [\n      // Note: There is a space at the end of the pattern here otherwise the\n      // /datetime rule can never be matched.\n      // these extra input patterns are needed until the block menu matches\n      // in places other than the start of a line\n      new InputRule(/\\/date\\s$/, ({ tr }, _match, start, end) => {\n        tr.delete(start, end).insertText(getCurrentDateAsString() + \" \");\n        this.editor.events.emit(EventType.blockMenuClose);\n        return tr;\n      }),\n      new InputRule(/\\/time\\s$/, ({ tr }, _match, start, end) => {\n        tr.delete(start, end).insertText(getCurrentTimeAsString() + \" \");\n        this.editor.events.emit(EventType.blockMenuClose);\n        return tr;\n      }),\n      new InputRule(/\\/datetime\\s$/, ({ tr }, _match, start, end) => {\n        tr.delete(start, end).insertText(`${getCurrentDateTimeAsString()} `);\n        this.editor.events.emit(EventType.blockMenuClose);\n        return tr;\n      }),\n    ];\n  }\n\n  commands(_options: { schema: Schema }) {\n    return {\n      date: () => (state: EditorState, dispatch: Dispatch) => {\n        dispatch(state.tr.insertText(getCurrentDateAsString() + \" \"));\n        return true;\n      },\n      time: () => (state: EditorState, dispatch: Dispatch) => {\n        dispatch(state.tr.insertText(getCurrentTimeAsString() + \" \"));\n        return true;\n      },\n      datetime: () => (state: EditorState, dispatch: Dispatch) => {\n        dispatch(state.tr.insertText(getCurrentDateTimeAsString() + \" \"));\n        return true;\n      },\n    };\n  }\n}\n","import { history, undo, redo } from \"prosemirror-history\";\nimport { undoInputRule } from \"prosemirror-inputrules\";\nimport Extension from \"../lib/Extension\";\n\nexport default class History extends Extension {\n  get name() {\n    return \"history\";\n  }\n\n  keys() {\n    return {\n      \"Mod-z\": undo,\n      \"Mod-y\": redo,\n      \"Shift-Mod-z\": redo,\n      Backspace: undoInputRule,\n    };\n  }\n\n  get plugins() {\n    return [history()];\n  }\n}\n","import { Plugin, Transaction } from \"prosemirror-state\";\nimport Extension from \"../lib/Extension\";\n\nexport default class MaxLength extends Extension {\n  get name() {\n    return \"maxlength\";\n  }\n\n  get plugins() {\n    return [\n      new Plugin({\n        filterTransaction: (tr: Transaction) => {\n          if (this.options.maxLength) {\n            const result = tr.doc && tr.doc.nodeSize > this.options.maxLength;\n            return !result;\n          }\n\n          return true;\n        },\n      }),\n    ];\n  }\n}\n","import { toggleMark } from \"prosemirror-commands\";\nimport { Plugin } from \"prosemirror-state\";\nimport { isInTable } from \"prosemirror-tables\";\nimport Extension from \"../lib/Extension\";\nimport isMarkdown from \"../lib/isMarkdown\";\nimport isUrl from \"../lib/isUrl\";\nimport selectionIsInCode from \"../queries/isInCode\";\nimport { LANGUAGES } from \"./Prism\";\n\nfunction isDropboxPaper(html: string): boolean {\n  // The best we have to detect if a paste is likely coming from Paper\n  // In this case it's actually better to use the text version\n  return html?.includes(\"usually-unique-id\");\n}\n\n/**\n * Add support for additional syntax that users paste even though it isn't\n * supported by the markdown parser directly by massaging the text content.\n *\n * @param text The incoming pasted plain text\n */\nfunction normalizePastedMarkdown(text: string): string {\n  const CHECKBOX_REGEX = /^\\s?(\\[(X|\\s|_|-)\\]\\s(.*)?)/gim;\n\n  // find checkboxes not contained in a list and wrap them in list items\n  while (text.match(CHECKBOX_REGEX)) {\n    text = text.replace(CHECKBOX_REGEX, (match) => `- ${match.trim()}`);\n  }\n\n  // find multiple newlines and insert a hard break to ensure they are respected\n  text = text.replace(/\\n{2,}/g, \"\\n\\n\\\\\\n\");\n\n  return text;\n}\n\nexport default class PasteHandler extends Extension {\n  get name() {\n    return \"markdown-paste\";\n  }\n\n  get plugins() {\n    return [\n      new Plugin({\n        props: {\n          transformPastedHTML(html: string) {\n            if (isDropboxPaper(html)) {\n              // Fixes double paragraphs when pasting from Dropbox Paper\n              html = html.replace(/<div><br><\\/div>/gi, \"<p></p>\");\n            }\n            return html;\n          },\n          handlePaste: (view, event: ClipboardEvent) => {\n            if (view.props.editable && !view.props.editable(view.state)) {\n              return false;\n            }\n            if (!event.clipboardData) {\n              return false;\n            }\n\n            const text = event.clipboardData.getData(\"text/plain\");\n            const html = event.clipboardData.getData(\"text/html\");\n            const vscode = event.clipboardData.getData(\"vscode-editor-data\");\n            const { state, dispatch } = view;\n\n            // first check if the clipboard contents can be parsed as a single\n            // url, this is mainly for allowing pasted urls to become embeds\n            if (isUrl(text)) {\n              // just paste the link mark directly onto the selected text\n              if (!state.selection.empty) {\n                toggleMark(this.editor.schema.marks.link, { href: text })(\n                  state,\n                  dispatch\n                );\n                return true;\n              }\n\n              // Is this link embeddable? Create an embed!\n              const { embeds } = this.editor.props;\n\n              if (embeds && !isInTable(state)) {\n                for (const embed of embeds) {\n                  const matches = embed.matcher(text);\n                  if (matches) {\n                    this.editor.commands.embed({\n                      href: text,\n                    });\n                    return true;\n                  }\n                }\n              }\n\n              // well, it's not an embed and there is no text selected – so just\n              // go ahead and insert the link directly\n              const transaction = view.state.tr\n                .insertText(text, state.selection.from, state.selection.to)\n                .addMark(\n                  state.selection.from,\n                  state.selection.to + text.length,\n                  state.schema.marks.link.create({ href: text })\n                );\n              view.dispatch(transaction);\n              return true;\n            }\n\n            // If the users selection is currently in a code block then paste\n            // as plain text, ignore all formatting and HTML content.\n            if (selectionIsInCode(view.state)) {\n              event.preventDefault();\n\n              view.dispatch(view.state.tr.insertText(text));\n              return true;\n            }\n\n            // Because VSCode is an especially popular editor that places metadata\n            // on the clipboard, we can parse it to find out what kind of content\n            // was pasted.\n            const vscodeMeta = vscode ? JSON.parse(vscode) : undefined;\n            const pasteCodeLanguage = vscodeMeta?.mode;\n\n            if (pasteCodeLanguage && pasteCodeLanguage !== \"markdown\") {\n              event.preventDefault();\n              view.dispatch(\n                view.state.tr\n                  .replaceSelectionWith(\n                    view.state.schema.nodes.code_fence.create({\n                      language: Object.keys(LANGUAGES).includes(vscodeMeta.mode)\n                        ? vscodeMeta.mode\n                        : null,\n                    })\n                  )\n                  .insertText(text)\n              );\n              return true;\n            }\n\n            // If the HTML on the clipboard is from Prosemirror then the best\n            // compatability is to just use the HTML parser, regardless of\n            // whether it \"looks\" like Markdown, see: outline/outline#2416\n            if (html?.includes(\"data-pm-slice\")) {\n              return false;\n            }\n\n            // If the text on the clipboard looks like Markdown OR there is no\n            // html on the clipboard then try to parse content as Markdown\n            if (\n              (isMarkdown(text) && !isDropboxPaper(html)) ||\n              html.length === 0 ||\n              pasteCodeLanguage === \"markdown\"\n            ) {\n              event.preventDefault();\n\n              const paste = this.editor.pasteParser.parse(\n                normalizePastedMarkdown(text)\n              );\n              const slice = paste.slice(0);\n\n              const transaction = view.state.tr.replaceSelection(slice);\n              view.dispatch(transaction);\n              return true;\n            }\n\n            // otherwise use the default HTML parser which will handle all paste\n            // \"from the web\" events\n            return false;\n          },\n        },\n      }),\n    ];\n  }\n}\n","export default function isMarkdown(text: string): boolean {\n  // code-ish\n  const fences = text.match(/^```/gm);\n  if (fences && fences.length > 1) {\n    return true;\n  }\n\n  // link-ish\n  if (text.match(/\\[[^]+\\]\\(https?:\\/\\/\\S+\\)/gm)) {\n    return true;\n  }\n  if (text.match(/\\[[^]+\\]\\(\\/\\S+\\)/gm)) {\n    return true;\n  }\n\n  // heading-ish\n  if (text.match(/^#{1,6}\\s+\\S+/gm)) {\n    return true;\n  }\n\n  // list-ish\n  const listItems = text.match(/^[\\d-*].?\\s\\S+/gm);\n  if (listItems && listItems.length > 1) {\n    return true;\n  }\n\n  return false;\n}\n","import { Plugin } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport Extension from \"../lib/Extension\";\n\nexport default class Placeholder extends Extension {\n  get name() {\n    return \"empty-placeholder\";\n  }\n\n  get defaultOptions() {\n    return {\n      emptyNodeClass: \"placeholder\",\n      placeholder: \"\",\n    };\n  }\n\n  get plugins() {\n    return [\n      new Plugin({\n        props: {\n          decorations: (state) => {\n            const { doc } = state;\n            const decorations: Decoration[] = [];\n            const completelyEmpty =\n              doc.textContent === \"\" &&\n              doc.childCount <= 1 &&\n              doc.content.size <= 2;\n\n            doc.descendants((node, pos) => {\n              if (!completelyEmpty) {\n                return;\n              }\n              if (pos !== 0 || node.type.name !== \"paragraph\") {\n                return;\n              }\n\n              const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                class: this.options.emptyNodeClass,\n                \"data-empty-text\": this.options.placeholder,\n              });\n              decorations.push(decoration);\n            });\n\n            return DecorationSet.create(doc, decorations);\n          },\n        },\n      }),\n    ];\n  }\n}\n","import { ellipsis, smartQuotes, InputRule } from \"prosemirror-inputrules\";\nimport Extension from \"../lib/Extension\";\n\nconst rightArrow = new InputRule(/->$/, \"→\");\n\nexport default class SmartText extends Extension {\n  get name() {\n    return \"smart_text\";\n  }\n\n  inputRules() {\n    return [rightArrow, ellipsis, ...smartQuotes];\n  }\n}\n","import { NodeType } from \"prosemirror-model\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport Extension from \"../lib/Extension\";\n\nexport default class TrailingNode extends Extension {\n  get name() {\n    return \"trailing_node\";\n  }\n\n  get defaultOptions() {\n    return {\n      node: \"paragraph\",\n      notAfter: [\"paragraph\", \"heading\"],\n    };\n  }\n\n  get plugins() {\n    const plugin = new PluginKey(this.name);\n    const disabledNodes = Object.entries(this.editor.schema.nodes)\n      .map(([, value]) => value)\n      .filter((node: NodeType) => this.options.notAfter.includes(node.name));\n\n    return [\n      new Plugin({\n        key: plugin,\n        view: () => ({\n          update: (view) => {\n            const { state } = view;\n            const insertNodeAtEnd = plugin.getState(state);\n\n            if (!insertNodeAtEnd) {\n              return;\n            }\n\n            const { doc, schema, tr } = state;\n            const type = schema.nodes[this.options.node];\n            const transaction = tr.insert(doc.content.size, type.create());\n            view.dispatch(transaction);\n          },\n        }),\n        state: {\n          init: (_, state) => {\n            const lastNode = state.tr.doc.lastChild;\n            return lastNode ? !disabledNodes.includes(lastNode.type) : false;\n          },\n          apply: (tr, value) => {\n            if (!tr.docChanged) {\n              return value;\n            }\n\n            const lastNode = tr.doc.lastChild;\n            return lastNode ? !disabledNodes.includes(lastNode.type) : false;\n          },\n        },\n      }),\n    ];\n  }\n}\n","import Extension from \"../lib/Extension\";\nimport Highlight from \"../marks/Highlight\";\nimport Mark from \"../marks/Mark\";\nimport TemplatePlaceholder from \"../marks/Placeholder\";\nimport Attachment from \"../nodes/Attachment\";\nimport Blockquote from \"../nodes/Blockquote\";\nimport BulletList from \"../nodes/BulletList\";\nimport CheckboxItem from \"../nodes/CheckboxItem\";\nimport CheckboxList from \"../nodes/CheckboxList\";\nimport CodeBlock from \"../nodes/CodeBlock\";\nimport CodeFence from \"../nodes/CodeFence\";\nimport Embed from \"../nodes/Embed\";\nimport Heading from \"../nodes/Heading\";\nimport HorizontalRule from \"../nodes/HorizontalRule\";\nimport ListItem from \"../nodes/ListItem\";\nimport Node from \"../nodes/Node\";\nimport Notice from \"../nodes/Notice\";\nimport OrderedList from \"../nodes/OrderedList\";\nimport Table from \"../nodes/Table\";\nimport TableCell from \"../nodes/TableCell\";\nimport TableHeadCell from \"../nodes/TableHeadCell\";\nimport TableRow from \"../nodes/TableRow\";\nimport BlockMenuTrigger from \"../plugins/BlockMenuTrigger\";\nimport Folding from \"../plugins/Folding\";\nimport Keys from \"../plugins/Keys\";\nimport basicPackage from \"./basic\";\n\nconst fullPackage: (typeof Node | typeof Mark | typeof Extension)[] = [\n  ...basicPackage,\n  CodeBlock,\n  CodeFence,\n  CheckboxList,\n  CheckboxItem,\n  Blockquote,\n  BulletList,\n  OrderedList,\n  Embed,\n  ListItem,\n  Attachment,\n  Notice,\n  Heading,\n  HorizontalRule,\n  Table,\n  TableCell,\n  TableHeadCell,\n  TableRow,\n  Highlight,\n  TemplatePlaceholder,\n  Folding,\n  Keys,\n  BlockMenuTrigger,\n];\n\nexport default fullPackage;\n","import Extension from \"../lib/Extension\";\nimport Bold from \"../marks/Bold\";\nimport Code from \"../marks/Code\";\nimport Italic from \"../marks/Italic\";\nimport Link from \"../marks/Link\";\nimport Mark from \"../marks/Mark\";\nimport Strikethrough from \"../marks/Strikethrough\";\nimport Underline from \"../marks/Underline\";\nimport Doc from \"../nodes/Doc\";\nimport Emoji from \"../nodes/Emoji\";\nimport HardBreak from \"../nodes/HardBreak\";\nimport Image from \"../nodes/Image\";\nimport Node from \"../nodes/Node\";\nimport Paragraph from \"../nodes/Paragraph\";\nimport Text from \"../nodes/Text\";\nimport ClipboardTextSerializer from \"../plugins/ClipboardTextSerializer\";\nimport DateTime from \"../plugins/DateTime\";\nimport History from \"../plugins/History\";\nimport MaxLength from \"../plugins/MaxLength\";\nimport PasteHandler from \"../plugins/PasteHandler\";\nimport Placeholder from \"../plugins/Placeholder\";\nimport SmartText from \"../plugins/SmartText\";\nimport TrailingNode from \"../plugins/TrailingNode\";\n\nconst basicPackage: (typeof Node | typeof Mark | typeof Extension)[] = [\n  Doc,\n  HardBreak,\n  Paragraph,\n  Emoji,\n  Text,\n  Image,\n  Bold,\n  Code,\n  Italic,\n  Underline,\n  Link,\n  Strikethrough,\n  History,\n  SmartText,\n  TrailingNode,\n  PasteHandler,\n  Placeholder,\n  MaxLength,\n  DateTime,\n  ClipboardTextSerializer,\n];\n\nexport default basicPackage;\n","import { MarkType } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\n\nconst isMarkActive = (type: MarkType) => (state: EditorState): boolean => {\n  if (!type) {\n    return false;\n  }\n\n  const { from, $from, to, empty } = state.selection;\n\n  return !!(empty\n    ? type.isInSet(state.storedMarks || $from.marks())\n    : state.doc.rangeHasMark(from, to, type));\n};\n\nexport default isMarkActive;\n","export default function isUrl(text: string) {\n  if (text.match(/\\n/)) {\n    return false;\n  }\n\n  try {\n    const url = new URL(text);\n    return url.hostname !== \"\";\n  } catch (err) {\n    return false;\n  }\n}\n"],"sourceRoot":""}